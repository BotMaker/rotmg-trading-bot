#Version 0.21.1
#Counter: 61
#WinCounter: 3
#Window 1
#TabInfo
TabText: Layer 0
TabRenamed: 0
TabNumber: 0
TabsetLayer: 0
#Control: Window1
X       : 0
Y       : 0
CX      : 638
CY      : 425
ControlLayer: 0
Title   : Rotmg 13.3 key gen
Class   : Window
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
BkColor : 0
SystemBkColor : BTNFACE
EnableC : 1
DefaultsClass : WS_SYSMENU
Style   : WS_DLGFRAME, WS_SYSMENU, WS_MINIMIZEBOX
TypStyle: {...}
ExStyle : WS_EX_DLGMODALFRAME
Local : 1
LastEditorEvent : 1

#Proc: (General)
include SrvSckIP.ew
include ARCFOUR.EW
include ARCFOUR2.EW
include item_ids.ew
include item_data.ew

include base64.ew
--setTimer(Window1,1001,1000)
--00359-OEM-8992687-00095
constant crypt32 = registerw32Library("crypto.dll")
constant xrsa_public_key_encyrp= registerw32Function(crypt32, "rsa_public_key_encyrp", {C_POINTER}, C_POINTER)


------------------------------------product reg----------------------------------------
integer register1,register2
register1=0
register2=0

constant  xttime= registerw32Function(crypt32, "ttime", {}, C_INT)

include reg.ew

function wrap_between(integer v,integer min,integer max)
  while v>max do
  	v-=max
  end while
  while v<min do
  	v+=max
  end while
  return v
end function


sequence buildguid,temp,oringalbuildguid,product_id

temp=regQueryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion","ProductId","")
integer pos
oringalbuildguid=temp
--puts(1,oringalbuildguid&"\n")

function real(sequence string)
sequence temp
temp=value(string)
return temp[2]
end function

constant client_key="rotmg,13.3,05"
constant server_key="gmtor,13.3,05"

constant client_enkey={'2','7','3','6','1','8','4','9','0','5'}
sequence client_dekey
client_dekey=repeat(0,10)

procedure client_dekey_init()
	integer pos
	pos=48
	for i=1 to 10 do
	   client_dekey[ (client_enkey[i]-48) +1] =pos
	   pos+=1
	end for
end procedure
client_dekey_init()


function serial_encrypt_keymap(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= client_enkey[(temp[i]-48)+1]
  end for	
  return st
end function

function serial_encrypt_client_xor(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= xor_bits(temp[i],client_key[pos])
  end for	
  return st
end function

function serial_encrypt_server_xor(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= xor_bits(temp[i],server_key[pos])
  	  pos+=1
  	  if pos>length(server_key) then
  	   pos=1
  	  end if
  end for	
  return st
end function

function serial_decrypt_keymap(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= client_dekey[(temp[i]-48)+1]
  	  pos+=1
  	  if pos>length(client_dekey) then
  	   pos=1
  	  end if
  end for	
  return st
end function

function serial_number(sequence temp)
sequence st
  st={}
  for i=1 to length(temp) do
    if temp[i]>='0' and temp[i]<='9' then
  	  st&= temp[i]
    end if	
  end for	
  return st
end function



function reg_get_serial_timestamp()
sequence data,pid
atom ttime
integer len

  data=serial_encrypt_client_xor(fromBase64(getText(textbox_serial)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 then
        return ttime
	  end if

  	end if
  	
    end if
  	
  end if		
end function


function reg_get_serial_timestamp2(sequence text)
sequence data,pid
atom ttime
integer len

  data=serial_encrypt_client_xor(fromBase64(text))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 then
        return ttime
	  end if

  	end if
  	
    end if
  	
  end if		
end function


procedure reg_is_active()
sequence data,pid,text
atom ttime,ftime
integer len,fn

  fn=open("reg.dat","r")

  if fn=-1 then
    setText(lable_message,"Botmaker,  The only verified legitimate download mpgh.net. Not Registered")
  	return
  end if

  text=gets(fn)

  data=serial_encrypt_server_xor(fromBase64(gets(fn)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
  	  data=data[1..(length(data)-4)]
  	  ftime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 and ftime=reg_get_serial_timestamp2(text) and ttime<=ftime+((60*60*24)*30) then
	    register1=1
	    register2=1
	    setEnable(button_generate,0)
	    setText(lable_message,"Botmaker, The only verified legitimate download mpgh.net. Registered remaining days: "&sprint( (ttime-ftime)/(60*60*24) ))
	    puts(1,"feture unlocked\n")
	  end if

  	end if
  	
    end if
  	
  end if
	
  close(fn)
end procedure


buildguid={}
if length(temp)<8 then
  puts(1,"unable to get serial error\n")	
else

buildguid=serial_number(temp)
product_id=serial_number(temp)

--puts(1,toBase64("testing base64 encoding poop"))
--puts(1,fromBase64(toBase64("testing base64 encoding poop")))
--puts(1,"tes")

temp=int_to_bytes(w32Func(xttime,{}))

--setText(textbox_serial,toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) )

--puts(1,serial_encrypt_client_xor(  fromBase64( toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) ) ) )

reg_is_active()


end if  ---product id larger


function texted(sequence data)
  atom message,result
  integer inc,char
  sequence text
  message=allocate_string(data)
  result=w32Func(xrsa_public_key_encyrp,{message})
  inc=0

  text=""
  while 1 do
  	char=peek(result+inc)
  	
  	if char=0 then
  		exit
  	end if
  	if char!=10 then
  	  text&=char
  	
  	end if
  	inc+=1
  end while

  free(message)
  return text
end function

--integer fid
--fid=open("fid.txt","w")
--puts(1,texted())
--puts(fid,texted("shdbshdvsdbsdbs"))
--close(fid)

--?texted("shdbshdvsdbsdbs")

constant debug_mode=0

atom items_bitmap
items_bitmap = loadBitmapFromFile( "renders.bmp" )

integer running,request_teleport,intrade,spam_one_time,enable_move_to_target,enable_auto_login,connected,trade_done_flag
running=0
request_teleport=0
intrade=0
spam_one_time=0
enable_move_to_target=0
sequence current_trading_name
current_trading_name=""
trade_done_flag=0

if register1=1 and register2=1 then
  setTimer(Window1,1099,1000*8)	
else
  setTimer(Window1,1099,1000*45)	
end if

enable_auto_login=0
--trade_completed=0
connected=0


sequence owner_name
integer owner_object_id
owner_name=""
owner_object_id=0

setCtlSize(List1,150,400)
setCtlSize(List2,150,400)

for i=1 to length(item_ids) do
  addItem(List1,item_ids[i][2])	
  addItem(List2,item_ids[i][2])	
end for

integer fn
sequence con_ip_address,con_email,con_pass,con_owner,con_amount1,con_amount2
integer con_index1,con_index2

fn=open("config.txt","r")
--con_ip_address=gets(fn)
--con_ip_address=con_ip_address[1..length(con_ip_address)-1]
con_email=gets(fn)
con_email=con_email[1..length(con_email)-1]
setText(textbox_email,con_email)
con_pass=gets(fn)
con_pass=con_pass[1..length(con_pass)-1]
setText(textbox_password,con_pass)
con_owner=gets(fn)
con_owner=con_owner[1..length(con_owner)-1]
setText(textbox_owner_name,con_owner)
con_index1=real(gets(fn))
con_index2=real(gets(fn))
con_amount1=sprint(real(gets(fn)))
con_amount2=sprint(real(gets(fn)))
setText(textbox_amount1,con_amount1)
setText(textbox_amount2,con_amount2)
setText(textbox_target_x,sprint(real(gets(fn))))
setText(textbox_target_y,sprint(real(gets(fn))))
enable_move_to_target=real(gets(fn))
setCheck(checkbox_move_to_target,enable_move_to_target)
enable_auto_login=real(gets(fn))
setCheck(checkbox_auto_login,enable_auto_login)
setCheck(checkbox_can_tell_owner,real(gets(fn)))
setCheck(checkbox_sound_tradedone,real(gets(fn)))
setCheck(checkbox_message_mode,real(gets(fn)))
close(fn)

  if isChecked(checkbox_message_mode)=0 then
  	setText(checkbox_message_mode,"Message Buying")
  else
    setText(checkbox_message_mode,"Message Selling")
  end if

setIndex(List1,con_index1)
setIndex(List2,con_index2)



sequence spam_message,spam_message2
integer spam_interval,spam_count
spam_message={}
spam_message2={}
spam_interval=1
spam_count=0


object junk
junk = {{},{}}
for j = 360 to 0 by -1 do
    junk[1] = append(junk[1], sin(j*PI/180) )
    junk[2] = append(junk[2], cos(j*PI/180) )
end for
constant sin_loTRUE2up = junk[1], cos_loTRUE2up = junk[2]

function point_distance(atom x1,atom y1 , atom x2, atom y2)
    atom x, y
    x = power(floor(x1) - floor(x2), 2)
    y = power(floor(y1) - floor(y2), 2)
    return sqrt(x + y)
end function

--targ.x += dist*Math.sin(Math.toRadians((90*gCli.index)+inca));
--		targ.y += dist*Math.cos(Math.toRadians((90*gCli.index)+inca));

constant space3dto2d=32
integer item_sell_id,item_sell_cost
integer item_buy_id,item_buy_cost
item_sell_id=0
item_buy_id=0
item_sell_cost=0
item_buy_cost=0

sequence item_sell_name
sequence item_buy_name
item_sell_name={}
item_buy_name={}

--for i=1 to length(item_ids) do
--  item_ids[i][2]

--end for

procedure centerwindow(integer win)
integer width,height,window_width,window_height
sequence size
    size=getCtlSize(win)
    window_width=size[1]
    window_height=size[2]
    width=w32Func(xGetSystemMetrics,{SM_CXSCREEN})
    height=w32Func(xGetSystemMetrics,{SM_CYSCREEN})
    setRect( win,floor((width/2))-floor((window_width/2)) ,floor((height/2))-floor((window_height/2))-32, window_width, window_height, 0 )
end procedure

--function rgb2( integer r, integer g, integer b )
--    return makecol(r,g,b)
--end function

sequence key_buffer
key_buffer={}

function remove_line(sequence string, integer line)
sequence temp
integer len
  len=length(string)
  if line=1 then
    return string[2..len]
  elsif line=len then
    return string[1..len-1]
  else
    temp=string[1..line-1]
    return temp&string[line+1..len]
  end if
end function

procedure key_add(integer scancode)
integer found
found=0
  for i=1 to length(key_buffer) do
    if key_buffer[i]=scancode then
      found=1
      exit
    end if
  end for
  if found=0 then
    key_buffer=append(key_buffer,scancode)
  end if
end procedure

procedure key_remove(integer scancode)
  for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       key_buffer=remove_line(key_buffer,i)
       exit
     end if
  end for
end procedure

function key_check(integer scancode)
   for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       return 1
     end if
  end for
  return 0
end function

constant window_titlebar_height = getSystemMetrics ( SM_CYCAPTION )
constant window_menu_height = getSystemMetrics ( SM_CYMENU )
constant window_hscrollbar_width = getSystemMetrics ( SM_CXVSCROLL )
constant window_vscrollbar_height = getSystemMetrics ( SM_CYVSCROLL )
constant window_border_width = getSystemMetrics ( SM_CXFRAME )
constant window_border_height = getSystemMetrics ( SM_CYFRAME )
constant window_toolbar_height = 33

constant window_all_height=window_titlebar_height+window_menu_height+window_toolbar_height+(getSystemMetrics ( SM_CYFRAME )*2)

function convert3dspaceto2d(atom v)
  sequence float
  integer haspoint,leftside,padleft,padright
  atom rightside
  haspoint=0

  float=sprint(v)
  for i=1 to length(float) do
  	if float[i]='.' then
  	  haspoint=1
  	  leftside=real(float[1..i-1])
  	  rightside=real("0."&float[i+1..length(float)])
  	end if
  end for

  if haspoint=1 then
    padleft=floor(space3dto2d*leftside)
  	padright=floor(space3dto2d*rightside)
  	return padleft+padright
  else
    return space3dto2d*v
  end if
end function


sequence map_data
integer map_width,map_height
map_width=255
map_height=255
map_data={}


--new main loop control

atom start_time
start_time=0
integer current_tick
current_tick=0

integer my_object_id
my_object_id=0

sequence my_position,my_name
my_position={}
sequence target_position
target_position={133,135}
sequence my_status
my_status={}
my_name={}
--end main loop control

--trading system
sequence my_items,my_items_selected,there_items,there_items_selected
my_items={}
there_items={}
my_items_selected=repeat(0,12)
there_items_selected=repeat(0,12)
integer trading_mode
trading_mode=0 --0 equals selling life for def, 1 equals selling def for life
--end trading system

sequence object_id_to_player_class
object_id_to_player_class=repeat(0,4000000) --2 million objects

constant player_constants={806,805,804,803,802,801,800,799,798,797,784,782,775,768}
sequence player_bitmap_offset
integer tmp
player_bitmap_offset=repeat(0,length(player_constants))
tmp=length(player_constants)

for i=1 to length(player_constants) do
  player_bitmap_offset[tmp]=(21*(i-1))+8
  tmp-=1
end for

include input_stream.ew
include output_stream.ew
include location.ew
include object_status.ew
include object_status_data.ew
include stat_data.ew
include tile.ew

include players.ew

constant inputstream = input_stream_new()
constant outputstream = output_stream_new()

integer first_update
sequence first_update_data
first_update=0
first_update_data={}
sequence update_state

update_state={0,0,0,0}

constant inputstream_update = input_stream_new()

constant xGetTickCount = registerw32Function(kernel32, "GetTickCount", {}, C_LONG)
constant xSleep = registerw32Procedure(kernel32, "Sleep", {C_LONG})

procedure usleep(integer v)
	w32Proc(xSleep,{v})
end procedure

function get_tick_count()
  return  w32Func(xGetTickCount,{})
end function

--public int currentTime() {
--		return (int) (System.currentTimeMillis() - startTime);
--	}

function current_time()
  return  w32Func(xGetTickCount,{})-start_time
end function




sequence send_buffer
send_buffer={}

global constant SM_ASYNC = #FFFF
atom hWndMainWindow
atom Server_sock
Server_sock=0

constant double_max_value=1.7976931348623157E308

function create_guest_guid_old()
  atom uid
  uid=	0.6176749197488145--+rand(1073741823)
  return uid*double_max_value	
end function

function create_guest_guid_java()
  integer fn,char
  sequence data
  fn=open("input.txt","w")
  start_time=get_tick_count()
  puts(fn,sprint(start_time))
  close(fn)
  if system_exec("guest.bat", 2) then
    puts(2, "failure!\n")
  end if
  fn=open("output.txt","rb")
  data=gets(fn)
  close(fn)
  return data
end function

function create_login_guid_java(sequence email,sequence pass)
  integer fn,char
  sequence data
  fn=open("input.txt","w")
  puts(fn,email&":"&pass)
  close(fn)
  --if system_exec("login.bat", 2) then
  --  puts(1, "failure!\n")
  --end if
  --if system_exec("crypto.exe tested asd", 2) then
  --  puts(1, "failure!\n")
  --end if
  fn=open("output.txt","rb")
  data=gets(fn)
  close(fn)
  for i=1 to length(data) do
  	if data[i]=' ' then
  	  data={data[1..i-1],data[i+1..length(data)]}
  	  exit	
  	end if
  end for
  return data
end function


procedure debug(sequence text)
  integer fn
  if debug_mode=1 then
  	fn=open("debug.txt","a")
    puts(fn, text)
  end if


  setText(console_output,text&getText(console_output))
  if debug_mode=1 then	
    close(fn)
  end if
end procedure
debug("Started\n")

sequence key1,key2

--these work
--key1 is for encrypting data to send to the client
key1={114,197,88,60,175,182,129,137,149,203,215,75,128}
--key2 is for decrypting data from the client
key2={49,31,128,105,20,81,199,27,9,161,58,42,110}
--finaly got rc4 encrption working 27/03/2013 --update streaming cipher working 03/05/2013

arcfour_init_encrypt(key1)
arcfour_init_encrypt2(key2)

-----------------------------write functions--------------------------------------

function writeutf(sequence data, sequence v)
  sequence s
   s=int_to_bytes(length(v))
   data&=s[2]&s[1]&v
   return data
end function

function writeint(sequence data ,atom v)
sequence s
   s=int_to_bytes(v)
   data&=s[4]&s[3]&s[2]&s[1]
   return data
end function

function writefloat(sequence data ,atom v)
sequence s
   s = atom_to_float32(v)
   data&=s[4]&s[3]&s[2]&s[1]
   return data
end function

function writebool(sequence data, integer b)
   data&=b
   return data
end function

function writeshort(sequence data ,atom v)
sequence s
   s=int_to_bytes(v)
   data&=s[2]&s[1]
   return data
end function

function writebyte(sequence data ,integer v)
   data&=v
   return data
end function

constant fail_packet=0
constant useportal_packet=3--USEPORTAL = 3;
constant ping_packet=6
constant global_notification_packet=9
constant tradedone_packet=12--TRADEDONE:int = 12;
constant shoot_packet=13
constant hello_packet=17
constant tradeaccepted_packet=18--TRADEACCEPTED = 18;
constant requesttrade_packet=21--REQUESTTRADE = 21;
constant tradechanged_packet=23--TRADECHANGED = 23;
constant text_packet=25 --TEXT
constant update_packet=26
constant create_suc_packet=31
constant create_packet=36
constant reconnect_packet=39--RECONNECT = 39;
constant play_sound_packet=44
constant load_packet=45
constant accountlist_packet=46
constant teleport_packet=49--TELEPORT = 49;
constant goto_packet=52
constant show_effect_packet=56
constant mapinfo_packet=60
constant traderequest_packet=61 --TRADEREQUESTED = 61;
constant new_tick_packet=62-- NEW_TICK = 62
constant notification_packet=63 --NOTIFICATION
constant tradestart_packet=67--TRADESTART = 67;
constant playertext_packet=69--PLAYERTEXT = 69;
constant allyshoot_packet=74 --ALLYSHOOT
constant clientstat_packet=75--CLIENTSTAT = 75;
constant invitedtoguild_packet=77--INVITEDTOGUILD = 77;


sequence packet_names
packet_names=repeat("",100)

packet_names[ fail_packet+1 ]= "failed"
packet_names[ useportal_packet+1 ]= "useportal"
packet_names[ ping_packet+1 ]= "ping"
packet_names[ global_notification_packet+1 ]= "global notifcaion"
packet_names[ tradedone_packet+1 ]= "tradedone"
packet_names[ shoot_packet+1 ]= "shoot"
packet_names[ hello_packet+1 ]= "hello"
packet_names[ tradeaccepted_packet+1 ] ="tradeaccepted"
packet_names[ requesttrade_packet+1 ]= "requesttrade"
packet_names[ tradechanged_packet+1 ]= "tradechanged"
packet_names[ text_packet+1 ]= "text"
packet_names[ update_packet+1 ]= "update"
packet_names[ create_suc_packet+1 ]= "create sucs"
packet_names[ create_packet+1 ]= "create packet"
packet_names[ reconnect_packet+1 ]= "reconnect"
packet_names[ play_sound_packet+1 ]= "play sound"
packet_names[ load_packet+1 ]= "load packet"
packet_names[ accountlist_packet+1 ]= "accountlist"
packet_names[ goto_packet+1 ]= "goto packet"
packet_names[ show_effect_packet+1 ]= "show effect"
packet_names[ mapinfo_packet+1 ]= "mapinfo"
packet_names[ traderequest_packet+1 ]= "traderequest"
packet_names[ new_tick_packet+1 ]= "new tick"
packet_names[ notification_packet+1 ]= "notification"
packet_names[ tradestart_packet+1 ]= "tradestart"
packet_names[ playertext_packet+1 ]= "playertext"
packet_names[ allyshoot_packet+1 ]= "allyshoot"
packet_names[ clientstat_packet+1 ]= "clientstat"
packet_names[ invitedtoguild_packet+1 ]= "invitedtoguild"

sequence minimap_data
constant minimap_width=256,minimap_height=256
minimap_data={}
atom minimap_bitmap
 minimap_bitmap = loadBitmapFromFile( "minimap.bmp" )

procedure minimap_load_data()
  integer fn,char,x,y
  fn=open("mapdata.txt","rb")

  for i=1 to minimap_height do
    minimap_data=append(minimap_data,repeat(0,minimap_width))
  end for

  x=1
  y=1
  while 1 do
  	char=getc(fn)
  	if char=-1 then--end of file
      exit
  	end if
  	minimap_data[y][x]=char
  	x+=1
  	if x>minimap_width then
  	  x=1
  	  y+=1
  	end if
  end while
	
  close(fn)
end procedure
--minimap_load_data()

procedure minimap_render()
--rgb()
--121
--58

  for y=1 to minimap_height do
  	for x=1 to minimap_width do
  	  if minimap_data[y][x]=122 then
  	  	setPixel( minimap_buffer, x-1, y-1, Blue )
  	  elsif minimap_data[y][x]=121 then
  	    setPixel( minimap_buffer, x-1, y-1, rgb(128,128,128) )
  	  elsif minimap_data[y][x]=58 then
  	  	setPixel( minimap_buffer, x-1, y-1, rgb(200,200,200) )
  	  elsif minimap_data[y][x]=0 then
  	    setPixel( minimap_buffer, x-1, y-1, Black )
  	  elsif minimap_data[y][x]=96 then
  	    setPixel( minimap_buffer, x-1, y-1, Black )
  	  elsif minimap_data[y][x]=35 then
  	    setPixel( minimap_buffer, x-1, y-1, rgb(0,200,0) )
  	  elsif minimap_data[y][x]=254 then
  	    setPixel( minimap_buffer, x-1, y-1, Red )
  	  end if
    end for
  end for

end procedure
--minimap_render()



procedure draw_my_items()
integer xx,yy
    xx=0
    yy=10

	for i=1 to length(my_status) do
	  if my_status[i][1]>=8 and my_status[i][1]<=19 then
	    if my_status[i][2]=4294967295 then
	
	  	     bitBlt( backbuffer,  -- copy to TheWindow
                  xx, yy,     -- put at {10,10} in TheWindow
                  items_bitmap,        -- copy from loaded bitmap
                  item_data[1][4], item_data[1][5],        -- upper left hand corner is {0,0}
                  40, 40,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
	    else
	  	for j=1 to length(item_data) do
	  	  if item_data[j][1]=my_status[i][2] then
	  	     bitBlt( backbuffer,  -- copy to TheWindow
                  xx, yy,     -- put at {10,10} in TheWindow
                  items_bitmap,        -- copy from loaded bitmap
                  item_data[j][4], item_data[j][5],        -- upper left hand corner is {0,0}
                  40, 40,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
	  	  	exit
	  	  end if
	  	end for
	  	end if
	  	xx+=40
	  	if xx>=(40*4) then
	  	  xx=0
	  	  yy+=40
	  	end if
	  end if
	end for
	
   copyBlt( Window1, 460, 0, backbuffer )
   --?666
end procedure


function hello_packet_write()
  sequence data,temp
  data={}
  data=writeutf(data,"13.3") --build version
  data=writeint(data,-2) --game id
  --data=writeutf(data,"XRU8xQGLzCLaQR2BMOVLE9aPLggIPbNcig/rA1Wyi+KnlfIO02VXKpDEMO7hjscFXccRGOnTHpKoLkbuo2OXrU0wGWzJLsNGSf007Ga71Eu6VCZ61dNIzm71qKl9B5z7ERceI/JFk9NQ7RvmdQpK1s+bB9qAsVWGwhlECBA4EU0=")--create_guest_guid_java())--"PAP6RSeDHDRLpNVO4dw7oMsZS/6gIdnSFj9LHjI/YL8Al61XUPAxMtx5d/fYzmdwbgdRed6X1pHcVKUX16q59wvlzVouQZeim0P8HwXxbuMWwS+Bf9YFUANoriQzjMV/PlNAc17GfxkVQAn2LNYSV3m+BfEAwE6/WUNtyIYZJWI=") --guid
  --data=writeutf(data,"Z+TWxbDpdKsNAKn358XZHOTI4nZEI4/oCrOB7CI8uDYdgWmXN4DKwfCcONgurW+xrGEWoLzviOyg5yRYxaeV55N7OB75OSGtslcs4Tjc8oNRILQG5wofw2YH+MG/jWshUfxC8yQBWJ/Akn+j1ROuS4+CEgjklZjLGC/Oc0EVgDQ=")

   --login deatils
  data=writeutf(data,texted(con_email))
  data=writeutf(data,texted(con_pass))
  --temp=create_login_guid_java(con_email,con_pass)
  --data=writeutf(data,temp[1])
  --data=writeutf(data,temp[2])
  --puts(1,temp[1]&"\n")
  --puts(1,temp[2]&"\n")

  --guest accoun login
  --data=writeutf(data,create_guest_guid_java())
  --data=writeutf(data,"") --pass

  data=writeutf(data,"")--texted("1368824702")) --secert
  data=writeint(data,-1) --key time
  data=writeshort(data,0)
  --data=writebyte(data,0) --
  data=writeint(data,0)  --jd length
  --data=writebyte(data,0) -- jd bytes

  data=writeutf(data,"") --pk
  data=writeutf(data,"rotmg") --tq
  data=writeutf(data,"") --h
  data=writeutf(data,"rotmg") --platforum

  data=writeutf(data,"") --unknow

  temp=reverse(int_to_bytes(length(data)+5)) &hello_packet

  data=arcfour_encrypt_block2(data)
  return temp & data
end function

procedure playertext_packet_write(sequence text)
sequence data,temp
  data={}
	data=writeutf(data,text)

  temp=reverse(int_to_bytes(length(data)+5)) &69

  data=arcfour_encrypt_block2(data)
  send_buffer=append(send_buffer,{temp&data})
end procedure

--integer map_width,map_height
sequence map_name

procedure mapinfo_packet_read(integer packet_length)
  object temp
  sequence data
  integer count
  count=0
	map_width=input_stream_readint(inputstream)
	count+=4
	map_height=input_stream_readint(inputstream)
	count+=4
	map_name=input_stream_readutf(inputstream)
	count+=length(map_name)+2
	temp=input_stream_readint(inputstream)
	count+=4
	temp=input_stream_readint(inputstream)
	count+=4
	temp=input_stream_readbool(inputstream)
	count+=1
	temp=input_stream_readbool(inputstream)
	count+=1
	
    --debug(input_stream_slice(inputstream,1, (packet_length-5)-count )&"\n")
    --need to slice the correct amount from the map info pack
    input_stream_set(inputstream, input_stream_slice(inputstream, ((packet_length-5)-count)+1, input_stream_length(inputstream) ) )
	
    map_data={}
    for i=1 to map_height do
      map_data=append(map_data,repeat(0,map_width))	
    end for
--init to zero
	
end procedure

function create_packet_write()
  sequence data,temp
  data={}

  data=writeshort(data,782)
  data=writeshort(data,0)

  temp=reverse(int_to_bytes(length(data)+5)) &create_packet

  data=arcfour_encrypt_block2(data)

  return temp & data
end function

function load_packet_write()
  sequence data,temp
  data={}

  data=writeint(data,1)

  temp=reverse(int_to_bytes(length(data)+5)) &45

  data=arcfour_encrypt_block2(data)
  return temp & data
end function

function useportal_packet_write(integer num)
  sequence data,temp
  data={}

  data=writeint(data,num)

  temp=reverse(int_to_bytes(length(data)+5)) &useportal_packet

  data=arcfour_encrypt_block2(data)
  return temp & data
end function


procedure create_suc_packet_read()
  object res
  debug("create_suc\n")
  my_object_id=input_stream_readint(inputstream)
  debug(sprint(my_object_id)&"\n")
  --?res
  res=input_stream_readint(inputstream)
  debug(sprint(res)&"\n")
  --?res
end procedure

sequence update_drop_list
update_drop_list={}

procedure update_packet_read()
  object res
  integer size,object_type,index
  integer found
  sequence temp,temp2,stats

  --new code optimizeation
  integer object_id
  sequence position
  integer class

  --
  integer fn
  atom direction

  --puts(1,"updated\n")
  size=input_stream_readshort(inputstream)

  --puts(1,"tile size "&sprint(size)&"\n")
  if size!=0 then --tiles
    --fn=open("tiles.txt","w")
  	for i=0 to size-1 do
  	  res=tile_new_from_input(inputstream)
  	  res=tile_get(res)
  	  map_data[res[2]][res[1]]=res[3]
  	  --puts(fn,sprint(tile_get_type(res))&"\n")
  	
    end for
    --for yy=1 to 255 do
      --for xx=1 to 255 do
      	--puts(fn,sprint(map_data[yy])&"\n")
      --end for	
    --end for
    --close(fn)

  end if

  size=input_stream_readshort(inputstream)
  --puts(1,"newobj size "&sprint(size)&"\n")
  if size!=0 then --new obj
  	for i=0 to size-1 do
  	  res=object_status_new_from_input(inputstream)
  	  temp=object_status_get(res)
  	  --?temp[1]--object type
  	  found=0
  	  for j=1 to length(player_constants) do
  	  	if temp[1]=player_constants[j] then
  	  	  found=j
  	  	end if
  	  end for
  	  if found!=0 then
  	  	
  	  --my object code--
  	  temp=object_status_data_get(temp[2])
  	  --puts(1,sprint(temp[1])&"\n")
  	  if temp[1]=my_object_id then
  	  	debug("my status updated\n")
  	  	--?i
  	  	--?size

  	  	--repaintRect( Window1, 560, 1, 560+160, 200 )
  	  	my_position=location_get(temp[2])
  	  	
        --direction=((315+rand(45))*PI/180)--((180+rand(180))*PI/180)
        --target_position[1]=my_position[1]+4*sin(direction)
        --target_position[2]=my_position[2]+4*cos(direction)
        --?target_position[1]
        --?target_position[2]
  	  	--my_position_real=my_position
  	  	my_status={}
  	  	for j=1 to length(temp[3]) do
  	  	  temp2=stat_data_get(temp[3][j])
  	  	  --?temp2
  	  	  if temp2[1]=31 then
  	  	  --	puts(1,temp2[3]&"\n")
  	  	  --	?j
  	  	    my_name=temp2[3]
  	  	  end if
  	  	  my_status=append(my_status,temp2)
  	  	end for
  	  	draw_my_items()
  	  	--?length(my_status)
  	  	--?my_status
  	  	--?location_get(temp[2])
  	  end if
  	  -- end my object code
  	
  	  stats={}
  	  temp=object_status_data_get(temp[2])
  	  for j=1 to length(temp[3]) do
  	  	temp2=stat_data_get(temp[3][j])
	  	if temp2[1]=31 then
  	  	   if equal(owner_name,temp2[3])=1 then
  	  	   	 owner_object_id=temp[1]
  	  	   end if
  	  	end if
  	  	stats=append(stats,temp2)
  	  end for
  	
      --player_list=append(player_list,{temp[1],stats,location_get(temp[2]),found})
      position=location_get(temp[2])
      object_id_to_player_class[temp[1]]=player_new(temp[1],stats,position,found,{convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2])},stats[29][3])

  	  object_status_delete(res)
  	
      end if

  	end for
  end if

  size=input_stream_readshort(inputstream)
  --puts(1,"drop size "&sprint(size)&"\n")

  for i=0 to size-1 do
  	 res=input_stream_readint(inputstream)
  	 update_drop_list&=res
     --new optimize code
     if object_id_to_player_class[res]!=0 then --object to be deleted is a player
       player_delete(object_id_to_player_class[res])
       object_id_to_player_class[res]=0
     end if

     if res=owner_object_id then
     	owner_object_id=0
     end if
     --end new optimized code
  	
  end for

    --UPDATEATT = 11;
  temp=reverse(int_to_bytes(length("")+5)) &11
  --write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp})
  --res=WsockSendData(Server_sock,temp)

end procedure


procedure global_notification_read()
   object res
    --puts(1,"global_notification \n")
	res=input_stream_readint(inputstream)
	res=input_stream_readutf(inputstream)
end procedure

procedure accountlist_read()
  object res
  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
  for i=0 to res-1 do
  	res=input_stream_readint(inputstream)
  end for
end procedure

procedure show_effect_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=input_stream_readint(inputstream)
end procedure

procedure allyshoot_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
  res=input_stream_readint(inputstream)
end procedure

procedure notification_read()
  object res
  res=input_stream_readint(inputstream)
  res=input_stream_readutf(inputstream)
  res=input_stream_readint(inputstream)
end procedure

procedure disconnect()
   debug("disconnect called\n")
   for i=1 to length(send_buffer) do
     --res=WsockSendData(Server_sock,send_buffer[i][1])
   end for
   send_buffer={}
   sleep(1)
   WsockCloseSocket(Server_sock)

   sleep(1)
   arcfour_init_encrypt(key1)
   arcfour_init_encrypt2(key2)
   input_stream_set(inputstream, "")

   my_position={}
   my_status={}
   my_name={}

   my_items={}
   there_items={}
   my_items_selected=repeat(0,12)
   there_items_selected=repeat(0,12)
   trading_mode=0
   current_trading_name=""


   --need to deallocate this correctly
   player_class_list={}
   my_object_id=0
   owner_object_id=0
   my_status={}
   player_freelist_delete()
   object_id_to_player_class=repeat(0,4000000) --2 million objects
end procedure


procedure new_tick_read()
  integer size,tick_id
  object res
  sequence temp,write,temp2,stats,temp_stat

  --new code optimizeation
  integer object_id
  sequence position
  integer class,count

  tick_id=input_stream_readint(inputstream)
  res=input_stream_readint(inputstream)
  size=input_stream_readshort(inputstream)

  for i=0 to size-1 do
  	res=object_status_data_new_from_input(inputstream)
  	
    temp=object_status_data_get(res)

    --new optimize code
    object_id=temp[1]
    if object_id_to_player_class[object_id]!=0 then --object to be updated is a player
      stats=player_stats_get(object_id_to_player_class[object_id])
      --?length(stats)
      for j=1 to length(temp[3]) do
      	temp_stat=stat_data_get(temp[3][j])
      	for k=1 to length(stats) do
      	  if temp_stat[1]=stats[k][1] then
      	  	stats[k]=temp_stat
      	  	exit
      	  end if	
      	end for
      end for

      if object_id=my_object_id then
      	my_status=stats
      end if

      position=location_get(temp[2])
      --if my_object_id=object_id then
      --	my_position=position
      --end if
      player_update( object_id_to_player_class[object_id],stats,position, {convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2]) } )
    end if
    --end new optimized code

  	object_status_data_delete(res)
  end for

  --if size!=0 then --cause a bug that cost me 2-3 hours to track down
  	current_tick=tick_id
  --end if

  write=""
  write=writeint(write,current_tick) --tick id
  --?current_tick
  --?tick_id
  write=writeint(write,current_time()) --time
  --position

  --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])
  if enable_move_to_target=1 then --
  	
  --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])
  if length(my_position) and point_distance(my_position[1],my_position[2],target_position[1],target_position[2])>1 then
    --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])

  	if my_position[1]<target_position[1] then
  	  my_position[1]+=0.10
  	else
	   my_position[1]-=0.10
  	end if
  	
    if my_position[2]<target_position[2] then
  	  my_position[2]+=0.10
  	else
	   my_position[2]-=0.10
  	end if
  end if
  --?my_position
  --?target_position
  end if

  if object_id_to_player_class[my_object_id]!=0 then
    count=0
    stats=player_stats_get(object_id_to_player_class[my_object_id])
    --?stats
    --?stats[9] --first equipment slot
    for i=13 to 13+8 do
      if stats[i][2]=item_sell_id then
    	count+=1
      end if	
    end for

    if count<item_sell_cost and running=1 then
      if isChecked(checkbox_can_tell_owner)=1 then
        playertext_packet_write("/tell "&owner_name&" sold the items, bot @"&my_name)
      end if
      debug("incorrect item to be sold or the amount of item to be sold is incorrect, or the bot has sold the items\n")
      debug("Stopped trading\n")
      --Beep( MB_OK )
      running=0
      setText(pushbutton_trading,"Start Trading")
      draw_my_items()
      --disconnect()
    else
      if count>=item_sell_cost and running=0 then
     	running=1
     	if isChecked(checkbox_can_tell_owner)=1 then
          playertext_packet_write("/tell "&owner_name&" Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name)
        end if
     	setText(pushbutton_trading,"Stop Trading")
      	draw_my_items()
      end if
    end if
    --sleep(10)
  end if


  if length(my_position) then
  write=writefloat(write,my_position[1])
  write=writefloat(write,my_position[2])

  write=writeshort(write,0)
  --Move = 7;
  temp=reverse(int_to_bytes(length(write)+5)) &7
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
  else
    write=writefloat(write,134)
  write=writefloat(write,142)

  write=writeshort(write,0)
  --Move = 7;
  temp=reverse(int_to_bytes(length(write)+5)) &7
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
  end if

  if request_teleport=1 then
  	request_teleport=0
  	if owner_object_id!=0 then
  	write=""
  	write=writeint(write,owner_object_id)
    temp=reverse(int_to_bytes(length(write)+5)) &49
    write=arcfour_encrypt_block2(write)
    send_buffer=append(send_buffer,{temp&write})
    end if
  end if

  --spam_message={"spam bot testing 00","spam bot testing 01"}
  if trading_mode=0 and running=1 and intrade=0 and spam_one_time=1 then
  	playertext_packet_write(spam_message[spam_interval]&" @"&my_name)
    spam_interval+=1
    if spam_interval>length(spam_message) then
  	  spam_interval=1
    end if
    spam_one_time=0
  end if

end procedure

procedure text_read()
  object res
  atom object_id
  res=input_stream_readutf(inputstream)
  object_id=input_stream_readint(inputstream)
  res=input_stream_readint(inputstream)
  res=input_stream_readbyte(inputstream)
  res=input_stream_readutf(inputstream)
  res=input_stream_readutf(inputstream)
  --puts(1,res&"\n")
  if object_id!=4294967295 and object_id_to_player_class[object_id]!=0 then
  	 player_message_set(object_id_to_player_class[object_id],{res,33*12})
  end if

  res=input_stream_readutf(inputstream)

  --	this.name_ = badi.readUTF(); // UTF
	--	this.objectId_ = badi.readInt(); // Int
	--	this.numStars_ = badi.readInt(); // Int
	--	this.bubbleTime_ = badi.readUnsignedByte(); // UnsignedByte
	--	this.recipient_ = badi.readUTF(); // UTF
	--	this.text_ = badi.readUTF(); // UTF
	--	this.cleanText_ = badi.readUTF(); // UTF
end procedure

atom ping_start
ping_start=0

procedure ping_read()
  object res
  sequence write,temp

  if ping_start=0 then
  	ping_start=time()
  end if
  --?(time()-ping_start)/2

  ping_start=time()

  res=input_stream_readint(inputstream)

  write=""
  --?res
  write=writeint(write,res) --serial
  write=writeint(write,current_time()) --time

  --PONG = 16;
  temp=reverse(int_to_bytes(length(write)+5)) &16
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})

end procedure

procedure goto_packet_read()
  object res
  sequence write,temp
  res=input_stream_readint(inputstream)
  if res=my_object_id then
    debug("yes set myposition\n")
    res=location_new_from_input(inputstream)
    my_position[1]=location_get_x(res)
    my_position[2]=location_get_y(res)
  else
    res=location_new_from_input(inputstream)
  end if

  location_delete(res)

  write=""
  write=writeint(write,current_time()) --time

  temp=reverse(int_to_bytes(length(write)+5)) &14
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
end procedure

procedure shoot_packet_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  if res=my_object_id then
  	debug("shoot_packet_testing")
  end if
  res=input_stream_readint(inputstream)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
end procedure

procedure play_sound_read()
  object res
  res=input_stream_readint(inputstream)
  res=input_stream_readbyte(inputstream)
end procedure

procedure traderequest_packet_read()
  object res
  sequence data,temp
  data={}
  res=input_stream_readutf(inputstream)
  debug("trade requested "&res&"\n")

  --automaticly trade upon request
  if running=1 then
    playertext_packet_write("/tell "&res&" Please select "&sprint(item_buy_cost)&" "&item_buy_name)
  	data=writeutf(data,res)
    temp=reverse(int_to_bytes(length(data)+5)) &21
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
  else
    if equal(res,owner_name) then
      data=writeutf(data,res)
      temp=reverse(int_to_bytes(length(data)+5)) &21
      data=arcfour_encrypt_block2(data)
      send_buffer=append(send_buffer,{temp&data})
    end if
  end if

end procedure

procedure check_there_item()
  integer count
  sequence temp
  count=0
  for i=5 to 12 do
  	if there_items[i][1]=item_buy_id then
  	  count+=1
  	end if
  end for	
  if count>=item_buy_cost then
  else
   if intrade=1 then
     debug("Trade incorrect items canceled\n")
     temp=reverse(int_to_bytes(length("")+5)) &1 --CANCELTRADE = 1;
     send_buffer=append(send_buffer,{temp})
     intrade=0
    end if
  end if
end procedure

procedure tradestart_packet_read()
  object res
  integer size
  atom item,bt,eq,included
  sequence data,temp
  size=input_stream_readshort(inputstream)
  my_items={}
  my_items_selected=repeat(0,12)
  for i=0 to size-1 do
    item=input_stream_readint(inputstream)
    bt=input_stream_readint(inputstream)
    eq=input_stream_readbool(inputstream)
    included=input_stream_readbool(inputstream)
	my_items=append(my_items,{item,bt,eq,included})
  end for

  --puts(1,"my items\n")
  --?my_items
  if debug_mode=1 then
  debug("trade start my_items\n")
  for i=1 to length(my_items) do
  	debug(sprint(my_items[i][1])&",")
  end for
  debug("\n")
  end if

  --fix a 18/05/2013 scam items bug
  res=input_stream_readutf(inputstream)
  current_trading_name=res
  --fix a 18/05/2013

  size=input_stream_readshort(inputstream)
  there_items={}
  there_items_selected=repeat(0,12)
  for i=0 to size-1 do
    item=input_stream_readint(inputstream)
    bt=input_stream_readint(inputstream)
    eq=input_stream_readbool(inputstream)
    included=input_stream_readbool(inputstream)
    there_items=append(there_items,{item,bt,eq,included})
  end for
  --puts(1,"there items\n")
  --?there_items
  if debug_mode=1 then
  debug("trade start there items\n")
  for i=1 to length(there_items) do
  	debug(sprint(there_items[i][1])&",")
  end for
  debug("\n")
  end if

  intrade=1

  if running=1 then
    if equal(current_trading_name,owner_name)=0  then
      check_there_item()--new version 03
    end if
  end if


  if equal(current_trading_name,owner_name) then --new version 5
    data={}
   --my item first
         data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) & 37  --CHANGETRADE = 37;
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & 57  --ACCEPTTRADE = 57
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})	

  end if

  setTimer(Window1,3000,1000*22) --22 second delay before closing the window

end procedure



procedure tradedone_packet_read()
  object res
  integer done,count
  done=0
  count=0
  res=input_stream_readint(inputstream)
  res=input_stream_readutf(inputstream)
  for i=1 to length(res) do
  	if res[i]='.' then
  	  for j=i+1 to length(res) do
  	  	if res[j]='"' then
  	  	  --puts(1,"found "&res[i+1..j-1]&"\n")
	      if equal("trade_successful",res[i+1..j-1])=1 then
	      	--trading_mode=not(trading_mode)
	      	trade_done_flag=1
	      	done=1
	      end if
  	  	  exit
  	  	end if
  	  end for	
  	  exit
  	end if
  end for

  intrade=0

  if done=1 then --new version 03

    if isChecked(checkbox_sound_tradedone)=1 then
      VOID = playSound("button-3.wav")	
    end if

    --repaintWindow(Window1)
    --repaintRect( Window1, 560, 1, 560+160, 200 )
  	--playertext_packet_write("/tell "&owner_name&" sold the items, bot @"&my_name)
  end if

  debug("tradedone "&res&"\n")
end procedure


procedure changetrade_packet_write(integer count)
  sequence data,temp
  integer tradedone,sel
  data={}


  --puts(1,owner_name&"\n")
  --puts(1,current_trading_name&"\n")
  if running=1 then

  if equal(current_trading_name,owner_name) then
        data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) & 37
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & 57
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})	
  else

  	tradedone=0
    sel=0
    if trading_mode=0 then
      if count>=item_buy_cost then
        for i=5 to 12 do
          if my_items[i][1]=item_sell_id then
            sel+=1
            my_items_selected[i]=1
            if sel>=item_sell_cost then
          	  tradedone=1
      	      exit
            end if
          end if
        end for
      else
        for i=5 to 12 do
      	  my_items_selected[i]=0
        end for
      end if
    end if

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,my_items_selected[i])
    end for
     if debug_mode=1 then
    debug("change pack write\n")
    debug(sprint(my_items_selected)&"\n")
    end if

    temp=reverse(int_to_bytes(length(data)+5)) & 37
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
    --ACCEPTTRADE = 57;
    if tradedone=1 then
  	  data=""
  	  data=writeshort(data,12)
      for i=1 to 12 do
  	    data=writebool(data,my_items_selected[i])
      end for
     data=writeshort(data,12)
     for i=1 to 12 do
  	   data=writebool(data,there_items_selected[i])
     end for
      temp=reverse(int_to_bytes(length(data)+5)) & 57
      data=arcfour_encrypt_block2(data)
      send_buffer=append(send_buffer,{temp&data})
    end if

  end if
  elsif running=0 and equal(current_trading_name,owner_name) then
    	
    data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) & 37
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & 57
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
  end if

end procedure

procedure tradechanged_packet_read()
  integer size,count
  object res
  sequence items
  items={}
  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    items&=res
  end for
  there_items_selected=items

  if debug_mode=1 then
  debug("there_items_selected\n")
  debug(sprint(there_items_selected)&"\n")
  end if
  --?items



  if trading_mode=0 then --selling life for 6 def
    count=0
  	for i=5 to 12 do
  	  if there_items[i][1]=item_buy_id and	there_items_selected[i]=1 then
  	  	count+=1
  	  end if
  	end for
  	changetrade_packet_write(count)
  end if

end procedure


procedure clientstat_packet_read()
  object res
  res=input_stream_readutf(inputstream)
  debug(res&"\n")
  res=input_stream_readint(inputstream)

end procedure

procedure reconnect_packet_read()
  object res
  integer size
  res=input_stream_readutf(inputstream)
  puts(1,"name "&res&"\n")
  res=input_stream_readutf(inputstream)
  puts(1,"host"&res&"\n")
  res=input_stream_readint(inputstream)
  puts(1,"port ")
  ?res
  puts(1,"\n")
  res=input_stream_readint(inputstream)
  puts(1,"game id")
  ?res
  puts(1,"\n")
  res=input_stream_readint(inputstream)
  puts(1,"key time")
  ?res
  size=input_stream_readshort(inputstream)
  ?size
  res=input_stream_readfully(inputstream,size)
  ?res
  --this.name_ = badi.readUTF(); // UTF
  --this.host_ = badi.readUTF(); // UTF
	--	this.port_ = badi.readInt(); // Int
	--	this.gameId_ = badi.readInt(); // Int
	--	this.keyTime_ = badi.readInt(); // Int
	--	short size = badi.readShort();
	--	this.key_ = new byte[size];
	--	badi.readFully(key_);

end procedure

procedure tradeaccepted_packet_read()
  --dummy function
  integer size,count
  object res
  sequence items
  items={}
  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    --items&=res
  end for

  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    --items&=res
  end for

end procedure

procedure invitedtoguild_packet_read()
  object res
  res=input_stream_readutf(inputstream)	
  res=input_stream_readutf(inputstream)	
end procedure


procedure connect_to_server()
	integer iwork, port
  sequence swork,ip

  port = 2050

  iwork = WsockInit()
  if iwork = -1 then -- WinSock failed
    iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    abort(99)
  end if

  hWndMainWindow = getHandle(Window1)
  --blocking connect, might need to make this none blocking
  Server_sock=Wsock_new("50.18.113.133", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  --Server_sock=Wsock_new("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

end procedure




--update_packet_read_backprocess(inputstream_update)

function update_packet_read_backprocess(integer inputstream)--basicly need to process this a bit at a time over 20 seconds
  object res
  integer size,object_type,index
  integer found
  sequence temp,temp2,stats

  --new code optimizeation
  integer object_id
  sequence position
  integer class

  --
  integer fn
  atom direction

  --puts(1,"updated\n")
  if update_state[1]=0 then
    size=input_stream_readshort(inputstream)	
    update_state[1]=size

    --puts(1,"start count\n")
    --?size
  else
   size=update_state[1]

  end if
  --size=input_stream_readshort(inputstream)

  --puts(1,"tile size "&sprint(size)&"\n")
  if size!=0  then --tiles
    --fn=open("tiles.txt","w")
  	for i=0 to size-1 do
  	  res=tile_new_from_input(inputstream)
  	  res=tile_get(res)
  	  --map_data[res[2]][res[1]]=res[3]
  	  --puts(fn,sprint(tile_get_type(res))&"\n")
  	  update_state[1]=size-(i+1)
      update_state[4]+=1
      if update_state[4]>40 then
      	update_state[4]=0
      	--puts(1,"end size\n")
      	--?update_state[1]
      	return 0
      end if
    end for
    --for yy=1 to 255 do
      --for xx=1 to 255 do
      	--puts(fn,sprint(map_data[yy])&"\n")
      --end for	
    --end for
    --close(fn)

  end if
  update_state[1]=-1

  if update_state[2]=0 then
    size=input_stream_readshort(inputstream)
    update_state[2]=size
  else
    size=update_state[2]
  end if

  --size=input_stream_readshort(inputstream)
  --puts(1,"newobj size "&sprint(size)&"\n")
  if size!=0  then --new obj
  	for i=0 to size-1 do
  	  --puts(1,"crap\n")
  	  --?i
  	  res=object_status_new_from_input(inputstream)
  	  temp=object_status_get(res)
  	  --?temp[1]--object type
  	  found=0
  	  for j=1 to length(player_constants) do
  	  	if temp[1]=player_constants[j] then
  	  	  found=j
  	  	end if
  	  end for
  	  if found!=0 then
  	  	
  	  --my object code--
  	  temp=object_status_data_get(temp[2])
  	  --puts(1,sprint(temp[1])&"\n")
  	  if temp[1]=my_object_id then
  	  	debug("my status updated\n")

  	  	--repaintRect( Window1, 560, 1, 560+160, 200 )
  	  	my_position=location_get(temp[2])
  	  	
        --direction=((315+rand(45))*PI/180)--((180+rand(180))*PI/180)
        --target_position[1]=my_position[1]+4*sin(direction)
        --target_position[2]=my_position[2]+4*cos(direction)
        --?target_position[1]
        --?target_position[2]
  	  	--my_position_real=my_position
  	  	my_status={}
  	  	for j=1 to length(temp[3]) do
  	  	  temp2=stat_data_get(temp[3][j])
  	  	  --?temp2
  	  	  if temp2[1]=31 then
  	  	  --	puts(1,temp2[3]&"\n")
  	  	  --	?j
  	  	    my_name=temp2[3]
  	  	    setText(label_bot_name,"Bot Name: " &my_name)
  	  	  end if
  	  	  my_status=append(my_status,temp2)
  	  	end for
  	  	draw_my_items()
  	  	--?length(my_status)
  	  	--?my_status
  	  	--?location_get(temp[2])
  	  end if
  	  -- end my object code
  	
  	  stats={}
  	  temp=object_status_data_get(temp[2])
  	  for j=1 to length(temp[3]) do
  	  	temp2=stat_data_get(temp[3][j])
	  	if temp2[1]=31 then
  	  	   if equal(owner_name,temp2[3])=1 then
  	  	   	 owner_object_id=temp[1]
  	  	   end if
  	  	end if
  	  	stats=append(stats,temp2)
  	  end for
  	
      --player_list=append(player_list,{temp[1],stats,location_get(temp[2]),found})
      position=location_get(temp[2])
      object_id_to_player_class[temp[1]]=player_new(temp[1],stats,position,found,{convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2])},stats[29][3])

  	  object_status_delete(res)
  	
      end if

      update_state[2]=size-(i+1)
      update_state[4]+=1
      if update_state[4]>20 then
      	update_state[4]=0
      	return 0
      end if

  	end for
  end if
   update_state[2]=-1

  --there a error somewhere with the above code think it size-(i+1) not sure without testing
  --size=input_stream_readshort(inputstream)
  --puts(1,"drop size "&sprint(size)&"\n")

  --for i=0 to size-1 do
  	-- res=input_stream_readint(inputstream)
  	
     --new optimize code
    -- if object_id_to_player_class[res]!=0 then --object to be deleted is a player
      -- player_delete(object_id_to_player_class[res])
      -- object_id_to_player_class[res]=0
     --end if
     --end new optimized code
  	
 --- end for


  for i=1 to length(update_drop_list) do
     --new optimize code
     if object_id_to_player_class[update_drop_list[i]]!=0 then --object to be deleted is a player
       player_delete(object_id_to_player_class[update_drop_list[i]])
       object_id_to_player_class[update_drop_list[i]]=0
     end if
  end for
  update_drop_list={}

  return 1 --done
end function

procedure read_packet()
  integer packet_id,packet_len,temp
  sequence data,fail_message,write
  object res

  --puts(1,"location class size "&sprint(location_classsize())&"\n")
  --puts(1,"object_status class size "&sprint(object_status_classsize())&"\n")
  --puts(1,"object_status_data class size "&sprint(object_status_data_classsize())&"\n")
  --puts(1,"stat_data class size "&sprint(stat_data_classsize())&"\n")
  --puts(1,"tile class size "&sprint(tile_classsize())&"\n")

  --puts(1,"size of  player_class_list "&sprint(length(player_class_list))&"\n")
  while 1 do


  if input_stream_length(inputstream)>5 and input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
  else
    exit
  end if

   for i=1 to length(send_buffer) do
     temp=WsockSendData(Server_sock,send_buffer[i][1])
     if temp!=length(send_buffer[i][1]) then
       if temp=-1 then
         debug("sending error socket error\n")
       else
	     debug("sending error sent: "&sprint(temp)&" total length: "&sprint(send_buffer[i][1])&"\n")
       end if
     end if
   end for
   send_buffer={}


  packet_id=input_stream_peek(inputstream,5)
  packet_len=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} )
	
  --puts(1,"packet id: "&packet_names[packet_id+1]&"\n")
  --?packet_id

  if input_stream_length(inputstream)>5 then
  	data=arcfour_decrypt_block(input_stream_slice(inputstream,6,packet_len))
  	
  	input_stream_set(inputstream, input_stream_slice(inputstream,packet_len+1, input_stream_length(inputstream) ) )
  	if packet_id=update_packet and first_update=0 then
  	  first_update=1
  	  update_state={0,0,0,0}
  	  first_update_data=data
  	  input_stream_set( inputstream_update, data)
  	else
  	  input_stream_set(inputstream, data&input_stream_get(inputstream))
  	end if
  	--input_stream_set(inputstream, data&input_stream_get(inputstream))
  	
  end if

  if packet_id=fail_packet then
    debug("fail\n")
  	debug(sprint(input_stream_readint(inputstream))&"\n")
  	fail_message=input_stream_readutf(inputstream)
  	debug(fail_message&"\n")
  	if length(fail_message)>6 then
  	  if fail_message[1]='A' and fail_message[2]='c' then
  	  	--account
  	  	--puts(1,"accouct in use found \n")
  	  	sleep(2)
  	  	disconnect()
        connect_to_server()
  	  end if	
  	end if
  elsif packet_id=ping_packet then
    ping_read()
  elsif packet_id=tradedone_packet then
    tradedone_packet_read()
  elsif packet_id=shoot_packet then
    shoot_packet_read()
  elsif packet_id=global_notification_packet then
    global_notification_read()
  elsif packet_id=play_sound_packet then
    play_sound_read()
  elsif packet_id=create_suc_packet then
    create_suc_packet_read()
  elsif packet_id=  tradeaccepted_packet then
    tradeaccepted_packet_read()
  elsif packet_id=tradechanged_packet then
    tradechanged_packet_read()
  elsif packet_id=accountlist_packet then
    accountlist_read()
  elsif packet_id=goto_packet then
    goto_packet_read()
  elsif packet_id= show_effect_packet then
    show_effect_read()
  elsif packet_id= text_packet then
    text_read()
  elsif packet_id=reconnect_packet then
    reconnect_packet_read()
  elsif packet_id=update_packet then
    --puts(1,"send_buffer\n")
    --?length(send_buffer)
    if first_update=1 then
      write=reverse(int_to_bytes(length("")+5)) &11
      send_buffer=append(send_buffer,{write})
      first_update=2
      debug("first update started\n")
      setTimer(Window1,4000,1000)
    else
	  update_packet_read()
	end if
	
  elsif packet_id= new_tick_packet then
    new_tick_read()
  elsif packet_id=tradestart_packet then
    tradestart_packet_read()
  elsif packet_id= traderequest_packet then
    traderequest_packet_read()
  elsif packet_id=  notification_packet then
     notification_read()
  elsif packet_id=mapinfo_packet then
  	mapinfo_packet_read(packet_len)
  elsif packet_id=	allyshoot_packet then
    allyshoot_read()
  elsif packet_id=clientstat_packet then
    clientstat_packet_read()
  elsif packet_id=invitedtoguild_packet then
    invitedtoguild_packet_read()
  else
    debug(sprint(packet_id)&"\n")
    debug("unknow packet\n")
    sleep(100)
  end if

  end while

    for i=1 to length(send_buffer) do
     temp=WsockSendData(Server_sock,send_buffer[i][1])
     if temp!=length(send_buffer[i][1]) then
       if temp=-1 then
         debug("sending error socket error\n")
       else
	     debug("sending error sent: "&sprint(temp)&" total length: "&sprint(send_buffer[i][1])&"\n")
       end if
     end if
   end for
   send_buffer={}


end procedure

procedure processServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork
  object    owork,junk
  sequence  newIP,swork,rx,tx
  sequence  data,temp

  action = lo_word(arg2)
  sock = arg1

  if action=FD_CONNECT then
    connected=1
  	debug("connected\n")
  	temp=hello_packet_write()
  	--puts(1,"send hello packet\n")
  	iwork=WsockSendData(sock,temp)
  	--?iwork
  	--?length(temp)
  	--iwork=WsockSendData(sock,create_packet_write())
  	--puts(1,"send load packet\n")
  	temp=load_packet_write()
  	iwork=WsockSendData(sock,temp)
  	--?iwork
  	--?length(temp)
  elsif action = FD_READ then
    rx = ""
    owork = WsockReadData(sock,1)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData(sock,1)
    end while
    if length(rx) > 0 then
      --puts(1,"packet recived\n")
      input_stream_append(inputstream,rx)

      if input_stream_length(inputstream)>5 then
        --puts(1,"packet length "&sprint(bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)})) &"  : actual len:"&sprint(input_stream_length(inputstream)) &"\n" )
        --puts(1,"packet id:"&sprint(input_stream_peek(inputstream,5))&"\n")

        if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          read_packet()	
        end if

      end if

    end if
  elsif action = FD_CLOSE then
     debug("server closed\n")
     WsockCloseSocket(sock)
     connected=0
     if enable_auto_login=1 then
       sleep(2)
       first_update=0
  	   disconnect()
       connect_to_server()
     end if
     --setTimer(Window1,1002,1000*60)
  end if
end procedure
#EndProc

#Proc: onClose
procedure Window1_onClose (integer self, integer event, sequence params)--params is ()
  running=0
  WsockCloseSocket(Server_sock)
  --returnValue(-1)

end procedure
setHandler( Window1, w32HClose, routine_id("Window1_onClose"))
#EndProc

#Proc: onEvent
procedure Window1_onEvent (integer self, integer event, sequence params)--params is ( int iMsg, atom wParm, atom lParm )
  if params[1] = SM_ASYNC then
	processServerMessage(hWndMainWindow,params[2],params[3])
  end if
end procedure
setHandler( Window1, w32HEvent, routine_id("Window1_onEvent"))
#EndProc

#Proc: onKeyDown
procedure Window1_onKeyDown (integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
  key_add(params[1])
end procedure
setHandler( Window1, w32HKeyDown, routine_id("Window1_onKeyDown"))
#EndProc

#Proc: onKeyUp
procedure Window1_onKeyUp (integer self, integer event, sequence params)--params is ( int scanCode, int shift )
  key_remove(params[1])
end procedure
setHandler( Window1, w32HKeyUp, routine_id("Window1_onKeyUp"))
#EndProc

#Proc: onOpen
procedure Window1_onOpen (integer self, integer event, sequence params)--params is ()
  integer iwork, port
  sequence swork,ip

  port = 2050

  iwork = WsockInit()
  if iwork = -1 then -- WinSock failed
    iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    abort(99)
  end if


  hWndMainWindow = getHandle(Window1)

  --blocking connect, might need to make this none blocking

  --Server_sock=Wsock_new(con_ip_address, 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  --Server_sock=Wsock_new("50.18.113.133", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

  --Server_sock=Wsock_new("127.0.0.1", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

  --Server_sock=WsockSocket(AF_INET,SOCK_STREAM)

  --if WSAAsyncSelect(Server_sock,hWndMainWindow,SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))!=0 then
  --	puts(1,"WSAAsyncSelect error\n")
  --end if

  --ip=WsockHostInfo("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com")
  --puts(1,ip[2])

  --?WsockConnectAsync(Server_sock,2050,ip[2])

  --Server = WsockListenAsync(port, hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_ACCEPT,FD_CLOSE,FD_WRITE}))

  --if Server_sock = SOCKET_ERROR then  -- WinSock failed
  --  iwork = message_box("WsockListenAsync() failed!","Error",MB_TASKMODAL+MB_ICONSTOP+MB_OK)
  --  abort(99)
  --end if


end procedure
setHandler( Window1, w32HOpen, routine_id("Window1_onOpen"))
#EndProc

#Proc: onPaint
procedure Window1_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
  --draw_my_items()
end procedure
setHandler( Window1, w32HPaint, routine_id("Window1_onPaint"))
#EndProc

#Proc: onTimer
procedure Window1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
sequence temp
  if params[1]=1001 then
  	--killTimer(Window1,1001)
  	
  	--main_loop()
  elsif params[1]=1002 then
  	Server_sock=Wsock_new("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  elsif params[1]=1099 then
  	spam_one_time=1
  elsif params[1]=2000 then
  	--if input_stream_length(inputstream)>5 then
     --   if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          --read_packet()	
      --  end if
     -- end if
  elsif params[1]=3000 then
    --new version 03
    if intrade=1 then
      debug("Trade timeout cancel\n")
      temp=reverse(int_to_bytes(length("")+5)) &1 --CANCELTRADE = 1;
      send_buffer=append(send_buffer,{temp})
      intrade=0

    end if
    killTimer(Window1,3000)
  elsif params[1]=4000 then
    if update_packet_read_backprocess(inputstream_update)=1 then
      killTimer(Window1,4000)
    end if
    --?input_stream_length(inputstream_update)
  end if
end procedure
setHandler( Window1, w32HTimer, routine_id("Window1_onTimer"))
#EndProc

#Control: lable_message
AWindow : 30
X       : 0
Y       : 0
CX      : 440
CY      : 20
ControlLayer: 0
Title   : Botmaker,  The only verified legitimate download mpgh.net.
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 9
Local : 1
OrigTitle : LText46

#Control: backbuffer
AWindow : 30
X       : 460
Y       : 0
CX      : 160
CY      : 160
ControlLayer: 0
Title   : 
Class   : Pixmap
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 33
Local : 1
OrigTitle : Bitmap28

#Control: LText5
AWindow : 30
X       : 30
Y       : 40
CX      : 40
CY      : 20
ControlLayer: 0
Title   : Email:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 3
Local : 1
OrigTitle : LText5

#Control: textbox_email
AWindow : 30
X       : 70
Y       : 40
CX      : 120
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 6
Local : 1
OrigTitle : EditText8

#Control: LText10
AWindow : 30
X       : 240
Y       : 40
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Sell item:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 8
Local : 1
OrigTitle : LText10

#Control: List1
AWindow : 30
X       : 300
Y       : 40
CX      : 150
CY      : 20
ControlLayer: 0
Title   : 
Class   : SortedCombo
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 1
Local : 1
OrigTitle : Combo4

#Control: LText6
AWindow : 30
X       : 10
Y       : 70
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Password:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 4
Local : 1
OrigTitle : LText6

#Control: textbox_password
AWindow : 30
X       : 70
Y       : 70
CX      : 120
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 5
Local : 1
OrigTitle : EditText7

#Control: LText13
AWindow : 30
X       : 240
Y       : 70
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Amount:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 18
Local : 1
OrigTitle : LText13

#Control: textbox_amount1
AWindow : 30
X       : 300
Y       : 70
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 1
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Numeric : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 19
Local : 1
OrigTitle : EditText14

#Control: LText18
AWindow : 30
X       : 0
Y       : 100
CX      : 70
CY      : 20
ControlLayer: 0
Title   : Owner Name:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 23
Local : 1
OrigTitle : LText18

#Control: textbox_owner_name
AWindow : 30
X       : 70
Y       : 100
CX      : 120
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 24
Local : 1
OrigTitle : EditText19

#Control: LText11
AWindow : 30
X       : 240
Y       : 100
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Buy item:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 11
Local : 1
OrigTitle : LText11

#Control: List2
AWindow : 30
X       : 300
Y       : 100
CX      : 150
CY      : 20
ControlLayer: 0
Title   : 
Class   : SortedCombo
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 17
Local : 1
OrigTitle : Combo12

#Control: checkbox_move_to_target
AWindow : 30
X       : 10
Y       : 130
CX      : 140
CY      : 20
ControlLayer: 0
Title   : Enable Move to Target 
Class   : CheckBox
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 31
Local : 1
OrigTitle : CheckBox26

#Control: LText15
AWindow : 30
X       : 240
Y       : 130
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Amount:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 20
Local : 1
OrigTitle : LText15

#Control: textbox_amount2
AWindow : 30
X       : 300
Y       : 130
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 1
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Numeric : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 21
Local : 1
OrigTitle : EditText16

#Control: LText22
AWindow : 30
X       : 20
Y       : 160
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Target x:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 27
Local : 1
OrigTitle : LText22

#Control: textbox_target_x
AWindow : 30
X       : 70
Y       : 160
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Numeric : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 28
Local : 1
OrigTitle : EditText23

#Control: LText24
AWindow : 30
X       : 130
Y       : 160
CX      : 50
CY      : 20
ControlLayer: 0
Title   : Target y:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 29
Local : 1
OrigTitle : LText24

#Control: textbox_target_y
AWindow : 30
X       : 180
Y       : 160
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 30
Local : 1
OrigTitle : EditText25

#Control: label_bot_name
AWindow : 30
X       : 240
Y       : 160
CX      : 180
CY      : 20
ControlLayer: 0
Title   : Bot Name: 
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 12
Local : 1
OrigTitle : LText45

#Control: checkbox_message_mode
AWindow : 30
X       : 10
Y       : 190
CX      : 120
CY      : 20
ControlLayer: 0
Title   : Message Selling 
Class   : CheckBox
Enabled : 0
Checked : 1
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 14
Local : 1
LastEditorEvent : 3
OrigTitle : CheckBox43

#Proc: onClick
procedure checkbox_message_mode_onClick (integer self, integer event, sequence params)--params is ()
  if isChecked(checkbox_message_mode)=0 then
  	setText(checkbox_message_mode,"Message Buying")
  else
    setText(checkbox_message_mode,"Message Selling")
  end if

end procedure
setHandler( checkbox_message_mode, w32HClick, routine_id("checkbox_message_mode_onClick"))
#EndProc

#Control: checkbox_sound_tradedone
AWindow : 30
X       : 140
Y       : 190
CX      : 140
CY      : 20
ControlLayer: 0
Title   : Sound On Trade Done
Class   : CheckBox
Enabled : 0
Checked : 1
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 15
Local : 1
OrigTitle : CheckBox42

#Control: checkbox_can_tell_owner
AWindow : 30
X       : 290
Y       : 190
CX      : 100
CY      : 20
ControlLayer: 0
Title   : Can Tell Owner 
Class   : CheckBox
Enabled : 0
Checked : 1
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 13
Local : 1
OrigTitle : CheckBox44

#Control: checkbox_auto_login
AWindow : 30
X       : 400
Y       : 190
CX      : 110
CY      : 20
ControlLayer: 0
Title   : Auto login on Dc
Class   : CheckBox
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 32
Local : 1
OrigTitle : CheckBox27

#Control: PushButton51
AWindow : 30
X       : 520
Y       : 190
CX      : 90
CY      : 20
ControlLayer: 0
Title   : REG
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 10
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton51

#Proc: onClick
procedure PushButton51_onClick (integer self, integer event, sequence params)--params is ()
  openWindow(Window3,Modal)
end procedure
setHandler( PushButton51, w32HClick, routine_id("PushButton51_onClick"))
#EndProc

#Control: PushButton9
AWindow : 30
X       : 10
Y       : 220
CX      : 120
CY      : 30
ControlLayer: 0
Title   : Connect to Server
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 7
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton9

#Proc: onClick
procedure PushButton9_onClick (integer self, integer event, sequence params)--params is ()

  con_email=getText(textbox_email)
  con_pass=getText(textbox_password)
  item_sell_name=getItem( List1, getIndex(List1) )
  item_buy_name=getItem( List2, getIndex(List2) )

  item_sell_cost=real(getText(textbox_amount1))
  item_buy_cost=real(getText(textbox_amount2))

  for i=1 to length(item_ids) do
    if equal(item_sell_name,item_ids[i][2])=1 then
      item_sell_id=item_ids[i][1]
    end if
    if equal(item_buy_name,item_ids[i][2])=1 then
      item_buy_id=item_ids[i][1]
    end if
  end for

  owner_name=getText(textbox_owner_name)

  target_position[1]=real(getText(textbox_target_x))
  target_position[2]=real(getText(textbox_target_y))
  --?target_position[1]
  --?target_position[2]

  enable_move_to_target=isChecked(checkbox_move_to_target)

  enable_auto_login=isChecked(checkbox_auto_login)

  if isChecked(checkbox_message_mode)=1 then
    spam_message={"Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name,
   "Selling> "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name}
  else
   spam_message={"Buying "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name,
   "Buying> "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name}
  end if

  connect_to_server()
end procedure
setHandler( PushButton9, w32HClick, routine_id("PushButton9_onClick"))
#EndProc

#Control: pushbutton_trading
AWindow : 30
X       : 140
Y       : 220
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Start Trading
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 22
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton17

#Proc: onClick
procedure pushbutton_trading_onClick (integer self, integer event, sequence params)--params is ()

    running=not(running)
    intrade=0


    if running=0 then
      debug("Stoped Trading\n")
      setText(pushbutton_trading,"Start Trading")
    elsif running=1 then
      debug("Start Trading\n")
      setText(pushbutton_trading,"Stop Trading")
    end if

    item_sell_name=getItem( List1, getIndex(List1) )
  item_buy_name=getItem( List2, getIndex(List2) )

  item_sell_cost=real(getText(textbox_amount1))
  item_buy_cost=real(getText(textbox_amount2))

  for i=1 to length(item_ids) do
    if equal(item_sell_name,item_ids[i][2])=1 then
      item_sell_id=item_ids[i][1]
    end if
    if equal(item_buy_name,item_ids[i][2])=1 then
      item_buy_id=item_ids[i][1]
    end if
  end for

  --owner_name=getText(textbox_owner_name)

  target_position[1]=real(getText(textbox_target_x))
  target_position[2]=real(getText(textbox_target_y))

  enable_move_to_target=isChecked(checkbox_move_to_target)
  enable_auto_login=isChecked(checkbox_auto_login)

  if isChecked(checkbox_message_mode)=1 then
    spam_message={"Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name,
    "Selling> "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name}
  else
    spam_message={"Buying "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name,
    "Buying> "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name}
  end if

  if isChecked(checkbox_can_tell_owner)=1 then
    playertext_packet_write("/tell "&owner_name&" Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name)
  end if
end procedure
setHandler( pushbutton_trading, w32HClick, routine_id("pushbutton_trading_onClick"))
#EndProc

#Control: PushButton20
AWindow : 30
X       : 240
Y       : 220
CX      : 110
CY      : 30
ControlLayer: 0
Title   : Teleport to Owner
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 25
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton20

#Proc: onClick
procedure PushButton20_onClick (integer self, integer event, sequence params)--params is ()
  request_teleport=1
end procedure
setHandler( PushButton20, w32HClick, routine_id("PushButton20_onClick"))
#EndProc

#Control: PushButton21
AWindow : 30
X       : 360
Y       : 220
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Save Config
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 26
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton21

#Proc: onClick
procedure PushButton21_onClick (integer self, integer event, sequence params)--params is ()
  integer fn
fn=open("config.txt","w")
puts(fn,getText(textbox_email)&"\n")
puts(fn,getText(textbox_password)&"\n")
puts(fn,getText(textbox_owner_name)&"\n")
puts(fn,sprint(getIndex(List1)) &"\n")
puts(fn,sprint(getIndex(List2)) &"\n")
puts(fn,getText(textbox_amount1)&"\n")
puts(fn,getText(textbox_amount2)&"\n")
puts(fn,getText(textbox_target_x)&"\n")
puts(fn,getText(textbox_target_y)&"\n")
puts(fn,sprint(isChecked(checkbox_move_to_target))&"\n")
puts(fn,sprint(isChecked(checkbox_auto_login))&"\n")
puts(fn,sprint(isChecked(checkbox_can_tell_owner))&"\n")
puts(fn,sprint(isChecked(checkbox_sound_tradedone))&"\n")
puts(fn,sprint(isChecked(checkbox_message_mode))&"\n")
close(fn)
end procedure
setHandler( PushButton21, w32HClick, routine_id("PushButton21_onClick"))
#EndProc

#Control: PushButton33
AWindow : 30
X       : 460
Y       : 220
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Minimap Pos
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 2
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton33

#Proc: onClick
procedure PushButton33_onClick (integer self, integer event, sequence params)--params is ()
  setText(textbox_minimap_x,getText(textbox_target_x))
  setText(textbox_minimap_y,getText(textbox_target_y))
  openWindow(Window2,Modal)
end procedure
setHandler( PushButton33, w32HClick, routine_id("PushButton33_onClick"))
#EndProc

#Control: PushButton30
AWindow : 30
X       : 560
Y       : 220
CX      : 60
CY      : 30
ControlLayer: 0
Title   : Refresh
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 34
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton30

#Proc: onClick
procedure PushButton30_onClick (integer self, integer event, sequence params)--params is ()
  draw_my_items()
end procedure
setHandler( PushButton30, w32HClick, routine_id("PushButton30_onClick"))
#EndProc

#Control: console_output
AWindow : 30
X       : 10
Y       : 260
CX      : 590
CY      : 124
ControlLayer: 0
Title   : 
Class   : MleText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 16
Local : 1
OrigTitle : MleText41

#Window 2
#TabInfo
TabText: Layer 0
TabRenamed: 0
TabNumber: 0
TabsetLayer: 0
#Control: Window2
X       : 0
Y       : 0
CX      : 282
CY      : 415
ControlLayer: 0
Title   : Minimap
Class   : Window
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
BkColor : 0
SystemBkColor : BTNFACE
EnableC : 1
Style   : 0
TypStyle: 
ExStyle : 0
Local : 1
LastEditorEvent : 1

#Proc: (General)

-- minimap_buffer,  -- copy to TheWindow
--                  0, 0,     -- put at {10,10} in TheWindow
--                  255, 255,    -- cause it to be this size
--                  minimap_bitmap,       -- copy from loaded bitmap
--                  90, 90,        -- upper left hand corner is {0,0}
--                  80, 70,     -- copy a 40x40 pixel portion
--                  SRCCOPY )   -- replace destination with image

function scale_mouse(integer startx, integer starty, integer width, integer height, integer mx, integer my  )
	atom scalex,scaley
	integer x,y
	scalex=width/minimap_width
	scaley=height/minimap_height
	
    x=(floor(mx*scalex)+startx)+1
    y=(floor(my*scaley)+starty)+1

    if x>startx+width then
      x=startx+width
    end if
    if y>startx+height then
      y=startx+height
    end if
	
    return {x,y}
end function
#EndProc

#Proc: onMouse
procedure Window2_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
sequence pos
  if params[1]=MouseMove then
    pos=scale_mouse(90,90,80,70,params[2],params[3])
  	setText(label_x,"x: "&sprint(pos[1]))
  	setText(label_y,"Y: "&sprint(pos[2]))
  elsif params[1]=LeftDown then
    pos=scale_mouse(90,90,80,70,params[2],params[3])
  	setText(textbox_minimap_x,sprint(pos[1]))
  	setText(textbox_minimap_y,sprint(pos[2]))
  end if
end procedure
setHandler( Window2, w32HMouse, routine_id("Window2_onMouse"))
#EndProc

#Proc: onPaint
procedure Window2_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
sequence pos
  pos={0,0}
  copyBlt( minimap_buffer,0,0,minimap_bitmap)

  stretchBlt( minimap_buffer,  -- copy to TheWindow
                  0, 0,     -- put at {10,10} in TheWindow
                  255, 255,    -- cause it to be this size
                  minimap_bitmap,       -- copy from loaded bitmap
                  90, 90,        -- upper left hand corner is {0,0}
                  80, 70,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
  --setPenColor( minimap_buffer, Green )
  --pos[1]=floor( real(getText(textbox_target_x))*(255/(90+80)) )
  --pos[2]=floor( real(getText(textbox_target_y))*(255/(90+70)) )

  --drawRectangle( minimap_buffer, w32True, pos[1], pos[2],pos[1]+4,pos[2]+4 )
  --setPixel(minimap_buffer,real(getText(textbox_target_x)),real(getText(textbox_target_y)),White)
  copyBlt( Window2, 0, 0, minimap_buffer )
end procedure
setHandler( Window2, w32HPaint, routine_id("Window2_onPaint"))
#EndProc

#Control: minimap_buffer
AWindow : 30
X       : 0
Y       : 0
CX      : 255
CY      : 255
ControlLayer: 0
Title   : 
Class   : Pixmap
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 1
Local : 1
OrigTitle : Bitmap32

#Control: label_x
AWindow : 30
X       : 20
Y       : 270
CX      : 60
CY      : 20
ControlLayer: 0
Title   : X:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 7
Local : 1
OrigTitle : LText39

#Control: label_y
AWindow : 30
X       : 90
Y       : 270
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Y:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 8
Local : 1
OrigTitle : LText40

#Control: textbox_minimap_x
AWindow : 30
X       : 20
Y       : 300
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
ReadOnly: 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 5
Local : 1
OrigTitle : EditText37

#Control: textbox_minimap_y
AWindow : 30
X       : 80
Y       : 300
CX      : 50
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
ReadOnly: 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 6
Local : 1
OrigTitle : EditText38

#Control: PushButton34
AWindow : 30
X       : 150
Y       : 300
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Refresh
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 2
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton34

#Proc: onClick
procedure PushButton34_onClick (integer self, integer event, sequence params)--params is ()
  copyBlt( minimap_buffer,0,0,minimap_bitmap)
  stretchBlt( minimap_buffer,  -- copy to TheWindow
                  0, 0,     -- put at {10,10} in TheWindow
                  255, 255,    -- cause it to be this size
                  minimap_bitmap,       -- copy from loaded bitmap
                  90, 90,        -- upper left hand corner is {0,0}
                  80, 70,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
  copyBlt( Window2, 0, 0, minimap_buffer )
end procedure
setHandler( PushButton34, w32HClick, routine_id("PushButton34_onClick"))
#EndProc

#Control: PushButton35
AWindow : 30
X       : 10
Y       : 340
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Save
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 3
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton35

#Proc: onClick
procedure PushButton35_onClick (integer self, integer event, sequence params)--params is ()
  target_position[1]=real(getText(textbox_minimap_x))
  target_position[2]=real(getText(textbox_minimap_y))
  setText(textbox_target_x,getText(textbox_minimap_x))
  setText(textbox_target_y,getText(textbox_minimap_y))
  closeWindow(Window2)
end procedure
setHandler( PushButton35, w32HClick, routine_id("PushButton35_onClick"))
#EndProc

#Control: PushButton36
AWindow : 30
X       : 150
Y       : 340
CX      : 90
CY      : 30
ControlLayer: 0
Title   : Cancel
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 4
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton36

#Proc: onClick
procedure PushButton36_onClick (integer self, integer event, sequence params)--params is ()
  closeWindow(Window2)
end procedure
setHandler( PushButton36, w32HClick, routine_id("PushButton36_onClick"))
#EndProc

#Window 3
#TabInfo
TabText: Layer 0
TabRenamed: 0
TabNumber: 0
TabsetLayer: 0
#Control: Window3
X       : 0
Y       : 0
CX      : 514
CY      : 206
ControlLayer: 0
Title   : Reg Edit
Class   : Window
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
BkColor : 0
SystemBkColor : BTNFACE
EnableC : 1
Style   : 0
TypStyle: 
ExStyle : 0
Local : 1

#Control: LText54
AWindow : 30
X       : 20
Y       : 40
CX      : 40
CY      : 20
ControlLayer: 0
Title   : Serial:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 1
Local : 1
OrigTitle : LText54

#Control: textbox_serial
AWindow : 30
X       : 60
Y       : 40
CX      : 290
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 3
Local : 1
OrigTitle : EditText53

#Control: button_generate
AWindow : 30
X       : 360
Y       : 40
CX      : 90
CY      : 20
ControlLayer: 0
Title   : Generate
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 5
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton57

#Proc: onClick
procedure button_generate_onClick (integer self, integer event, sequence params)--params is ()
  sequence temp
  integer ret
  ret = message_box("Warning don't generate a new serial while waiting to be Registered\nDo you want to generate a new serial?","Warning",MB_YESNO)

  if ret=IDNO then
    returnValue(1)
    return
  end if

  ret = message_box("Warning don't generate a new serial while waiting to be Registered\nThe activation key will be invalid and no refund will be given  \nDo you want to generate a new serial?","Warning Confirm",MB_YESNO)

  if ret=IDNO then
    returnValue(1)
    return
  end if

  temp=int_to_bytes(w32Func(xttime,{}))
  setText(textbox_serial,toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) )
end procedure
setHandler( button_generate, w32HClick, routine_id("button_generate_onClick"))
#EndProc

#Control: LText55
AWindow : 30
X       : 0
Y       : 70
CX      : 60
CY      : 20
ControlLayer: 0
Title   : Serial key:
Class   : LText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 2
Local : 1
OrigTitle : LText55

#Control: textbox_serial_key
AWindow : 30
X       : 60
Y       : 70
CX      : 290
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 4
Local : 1
OrigTitle : EditText56

#Control: PushButton58
AWindow : 30
X       : 360
Y       : 70
CX      : 90
CY      : 20
ControlLayer: 0
Title   : Activate 
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 6
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton58

#Proc: onClick
procedure PushButton58_onClick (integer self, integer event, sequence params)--params is ()

sequence data,pid
atom ttime,ftime
integer len,fn

  data=serial_encrypt_server_xor(fromBase64(getText(textbox_serial_key)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
  	  data=data[1..(length(data)-4)]
  	  ftime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 and ftime=reg_get_serial_timestamp() then
	    fn=open("reg.dat","w")
	    puts(fn,getText(textbox_serial)&"\n")
        puts(fn,getText(textbox_serial_key)&"\n")
        setEnable(button_generate,0)
        close(fn)
	  end if

  	end if
  	
    end if
  	
  end if
end procedure
setHandler( PushButton58, w32HClick, routine_id("PushButton58_onClick"))
#EndProc

#Control: textbox_temp
AWindow : 30
X       : 50
Y       : 110
CX      : 240
CY      : 20
ControlLayer: 0
Title   : 
Class   : EditText
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 7
Local : 1
OrigTitle : EditText60

#Control: PushButton61
AWindow : 30
X       : 330
Y       : 110
CX      : 110
CY      : 30
ControlLayer: 0
Title   : create working key
Class   : PushButton
Enabled : 0
Checked : 0
Parent  : 
PClass  : 
SeqParentName  : 
SeqParentClass  : 
SeqChildName  : 
Visible : 1
EnableC : 1
Style   : 
TypStyle: 
ExStyle : 0
TabOrder : 8
Local : 1
LastEditorEvent : 3
OrigTitle : PushButton61

#Proc: onClick
procedure PushButton61_onClick (integer self, integer event, sequence params)--params is ()
sequence data,pid,key
atom ttime,day30
integer len
  data=serial_encrypt_client_xor(fromBase64(getText(textbox_serial)))

  setText(textbox_temp,data)

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then
  		
  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]

	  pid=data
	  --if equal(pid,product_id)=1 then
	  	day30=(60*60*24)*30
	  	--ttime+=day30
	  	
	  	key=pid&int_to_bytes(ttime)&int_to_bytes(ttime+day30)&sprint(length(pid)+8)
	  	setText(textbox_serial_key, toBase64(serial_encrypt_server_xor(  key )))
	  --end if

  	end if
  	
    end if
  	
  end if

end procedure
setHandler( PushButton61, w32HClick, routine_id("PushButton61_onClick"))
#EndProc

