--  code generated by Win32Lib IDE v0.21.1 Build Sept-29-2006

constant TheProgramType="exw" 
 
include Win32Lib.ew
without warning

--------------------------------------------------------------------------------
--  Window Window1
sequence IDEFlags
IDEFlags = classDefaults(Window, { {1, {WS_SYSMENU}},{2, {WS_EX_DLGMODALFRAME}} } )
constant Window1 = createEx( Window, "Rotmg 27.3.1 Trading Bot - Version 11", 0, Default, Default, 637, 471, {WS_DLGFRAME, WS_SYSMENU, WS_MINIMIZEBOX}, {WS_EX_DLGMODALFRAME} )
constant lable_message = createEx( LText, "Botmaker,  The only verified legitimate download mpgh.net.", Window1, 0, 0, 440, 20, 0, 0 )
constant backbuffer = createEx( Pixmap, "", Window1, 460, 0, 160, 160, 0, 0 )
constant LText63 = createEx( LText, "Server:", Window1, 30, 20, 40, 20, 0, 0 )
constant combox_serverlist = createEx( Combo, "", Window1, 70, 20, 120, 20*6, 0, 0 )
constant LText5 = createEx( LText, "Email:", Window1, 30, 40, 40, 20, 0, 0 )
constant textbox_email = createEx( EditText, "", Window1, 70, 40, 120, 20, 0, 0 )
constant LText10 = createEx( LText, "Sell item:", Window1, 240, 40, 50, 20, 0, 0 )
constant List1 = createEx( SortedCombo, "", Window1, 300, 40, 150, 20, 0, 0 )
constant LText6 = createEx( LText, "Password:", Window1, 10, 70, 60, 20, 0, 0 )
constant textbox_password = createEx( EditText, "", Window1, 70, 70, 120, 20, 0, 0 )
constant LText13 = createEx( LText, "Amount:", Window1, 240, 70, 50, 20, 0, 0 )
constant textbox_amount1 = createEx( EditText, "1", Window1, 300, 70, 50, 20, w32or_all({#2000}), 0 )
constant LText18 = createEx( LText, "Owner Name:", Window1, 0, 100, 70, 20, 0, 0 )
constant textbox_owner_name = createEx( EditText, "", Window1, 70, 100, 120, 20, 0, 0 )
constant LText11 = createEx( LText, "Buy item:", Window1, 240, 100, 50, 20, 0, 0 )
constant List2 = createEx( SortedCombo, "", Window1, 300, 100, 150, 20, 0, 0 )
constant checkbox_move_to_target = createEx( CheckBox, "Enable Move to Target ", Window1, 10, 130, 140, 20, 0, 0 )
constant LText15 = createEx( LText, "Amount:", Window1, 240, 130, 50, 20, 0, 0 )
constant textbox_amount2 = createEx( EditText, "1", Window1, 300, 130, 50, 20, w32or_all({#2000}), 0 )
constant LText22 = createEx( LText, "Target x:", Window1, 20, 160, 50, 20, 0, 0 )
constant textbox_target_x = createEx( EditText, "", Window1, 70, 160, 50, 20, w32or_all({#2000}), 0 )
constant LText24 = createEx( LText, "Target y:", Window1, 130, 160, 50, 20, 0, 0 )
constant textbox_target_y = createEx( EditText, "", Window1, 180, 160, 50, 20, 0, 0 )
constant label_bot_name = createEx( LText, "Bot Name: ", Window1, 240, 160, 150, 20, 0, 0 )
constant checkbox_hide = createEx( CheckBox, "hotkey hiding", Window1, 520, 160, 90, 20, 0, 0 )
setCheck( checkbox_hide, w32True )
constant check_enable_custom_message = createEx( CheckBox, "Custom message", Window1, 400, 170, 110, 20, 0, 0 )
constant PushButton64 = createEx( PushButton, "Custom Message", Window1, 520, 180, 90, 20, 0, 0 )
constant checkbox_message_mode = createEx( CheckBox, "Message Selling ", Window1, 10, 190, 120, 20, 0, 0 )
setCheck( checkbox_message_mode, w32True )
constant checkbox_sound_tradedone = createEx( CheckBox, "Sound On Trade Done", Window1, 140, 190, 140, 20, 0, 0 )
setCheck( checkbox_sound_tradedone, w32True )
constant checkbox_can_tell_owner = createEx( CheckBox, "Can Tell Owner ", Window1, 290, 190, 100, 20, 0, 0 )
setCheck( checkbox_can_tell_owner, w32True )
constant checkbox_auto_login = createEx( CheckBox, "Auto login on Dc", Window1, 400, 190, 110, 20, 0, 0 )
constant PushButton51 = createEx( PushButton, "REG", Window1, 520, 200, 90, 20, 0, 0 )
constant PushButton9 = createEx( PushButton, "Connect to Server", Window1, 10, 220, 120, 30, 0, 0 )
constant pushbutton_trading = createEx( PushButton, "Start Trading", Window1, 140, 220, 90, 30, 0, 0 )
constant PushButton20 = createEx( PushButton, "Teleport to Owner", Window1, 240, 220, 110, 30, 0, 0 )
constant PushButton21 = createEx( PushButton, "Save Config", Window1, 360, 220, 90, 30, 0, 0 )
constant PushButton33 = createEx( PushButton, "Minimap Pos", Window1, 460, 220, 90, 30, 0, 0 )
constant PushButton30 = createEx( PushButton, "Refresh", Window1, 560, 220, 60, 30, 0, 0 )
constant checkbox_slot1 = createEx( CheckBox, "Slot 1", Window1, 20, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot1, w32True )
constant checkbox_slot2 = createEx( CheckBox, "Slot 2", Window1, 80, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot2, w32True )
constant checkbox_slot3 = createEx( CheckBox, "Slot 3", Window1, 140, 260, 60, 20, 0, 0 )
setCheck( checkbox_slot3, w32True )
constant checkbox_slot4 = createEx( CheckBox, "Slot 4", Window1, 210, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot4, w32True )
constant checkbox_slot5 = createEx( CheckBox, "Slot 5", Window1, 270, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot5, w32True )
constant checkbox_slot6 = createEx( CheckBox, "Slot 6", Window1, 330, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot6, w32True )
constant checkbox_slot7 = createEx( CheckBox, "Slot 7", Window1, 390, 260, 60, 20, 0, 0 )
setCheck( checkbox_slot7, w32True )
constant checkbox_slot8 = createEx( CheckBox, "Slot 8", Window1, 460, 260, 50, 20, 0, 0 )
setCheck( checkbox_slot8, w32True )
constant PushButton79 = createEx( PushButton, "select all or deselect all", Window1, 520, 260, 120, 20, 0, 0 )
constant LText82 = createEx( LText, "Chat Interval Seconds", Window1, 20, 290, 120, 20, 0, 0 )
constant textbox_chattime = createEx( EditText, "45", Window1, 150, 290, 60, 20, w32or_all({#2000}), 0 )
constant PushButton83 = createEx( PushButton, "Set ", Window1, 230, 290, 60, 20, 0, 0 )
constant checkbox_showname = createEx( CheckBox, "Show name", Window1, 320, 290, 150, 20, 0, 0 )
setCheck( checkbox_showname, w32True )
constant LText86 = createEx( LText, "Build Version", Window1, 480, 290, 80, 20, 0, 0 )
constant textbox_rotmg_build_version = createEx( EditText, "16.2", Window1, 570, 290, 40, 20, 0, 0 )
constant console_output = createEx( MleText, "", Window1, 10, 310, 600, 120, 0, 0 )
setEnable( PushButton20, w32False )
setEnable( PushButton33, w32False )
---------------------------------------------------------
--------------------------------------------------------------------------------
--  Window Window2
constant Window2 = createEx( Window, "Minimap", 0, Default, Default, 282, 415, 0, 0 )
constant minimap_buffer = createEx( Pixmap, "", Window2, 0, 0, 255, 255, 0, 0 )
constant label_x = createEx( LText, "X:", Window2, 20, 270, 60, 20, 0, 0 )
constant label_y = createEx( LText, "Y:", Window2, 90, 270, 60, 20, 0, 0 )
constant textbox_minimap_x = createEx( EditText, "", Window2, 20, 300, 50, 20, w32or_all({ES_READONLY}), 0 )
constant textbox_minimap_y = createEx( EditText, "", Window2, 80, 300, 50, 20, w32or_all({ES_READONLY}), 0 )
constant PushButton34 = createEx( PushButton, "Refresh", Window2, 150, 300, 90, 30, 0, 0 )
constant PushButton35 = createEx( PushButton, "Save", Window2, 10, 340, 90, 30, 0, 0 )
constant PushButton36 = createEx( PushButton, "Cancel", Window2, 150, 340, 90, 30, 0, 0 )
---------------------------------------------------------
--------------------------------------------------------------------------------
--  Window Window3
constant Window3 = createEx( Window, "Reg Edit", 0, Default, Default, 514, 179, 0, 0 )
constant LText54 = createEx( LText, "Serial:", Window3, 20, 40, 40, 20, 0, 0 )
constant textbox_serial = createEx( EditText, "", Window3, 60, 40, 290, 20, w32or_all({ES_READONLY}), 0 )
constant button_generate = createEx( PushButton, "Generate", Window3, 360, 40, 90, 20, 0, 0 )
constant LText55 = createEx( LText, "Serial key:", Window3, 0, 70, 60, 20, 0, 0 )
constant textbox_serial_key = createEx( EditText, "", Window3, 60, 70, 290, 20, 0, 0 )
constant PushButton58 = createEx( PushButton, "Activate ", Window3, 360, 70, 90, 20, 0, 0 )
---------------------------------------------------------
--------------------------------------------------------------------------------
--  Window Window4
constant Window4 = createEx( Window, "Custom Message", 0, Default, Default, 512, 231, 0, 0 )
constant textbox_custom_text = createEx( MleText, "", Window4, 0, 0, 490, 150, 0, 0 )
constant PushButton68 = createEx( PushButton, "Save", Window4, 190, 160, 90, 30, 0, 0 )
---------------------------------------------------------
--------------------------------------------------------------------------------



include SrvSckIP.ew
include ARCFOUR.EW
include ARCFOUR2.EW
include item_ids.ew
include item_data.ew

integer inv_select
inv_select=0

integer paused
integer hotkey_1,hotkey_2
hotkey_1=0
hotkey_2=0
paused=0

setTimer(Window1,1001,50)

integer hotkey1_scancode,hotkey2_scancode
hotkey1_scancode=17
hotkey2_scancode=49

constant xGetAsyncKeyState = registerw32Function(user32, "GetAsyncKeyState", {C_INT}, C_SHORT)

function KeyState(int key)
	return w32Func( xGetAsyncKeyState, { key } )
end function

--?KeyState('W')
--?'W'


include base64.ew
--setTimer(Window1,1001,1000)
--00359-OEM-8992687-00095
constant crypt32 = registerw32Library("crypto.dll")
constant xrsa_public_key_encyrp= registerw32Function(crypt32, "rsa_public_key_encyrp", {C_POINTER}, C_POINTER)


------------------------------------product reg----------------------------------------
integer register1,register2
register1=0
register2=0



constant  xttime= registerw32Function(crypt32, "ttime", {}, C_INT)

include reg.ew

function wrap_between(integer v,integer min,integer max)
  while v>max do
  	v-=max
  end while
  while v<min do
  	v+=max
  end while
  return v
end function


sequence buildguid,temp,oringalbuildguid,product_id

temp=regQueryValue("HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion","ProductId","")
integer pos
oringalbuildguid=temp
--puts(1,oringalbuildguid&"\n")

function real(sequence string)
sequence temp
temp=value(string)
return temp[2]
end function

constant client_key="rotmg,13.3,05"
constant server_key="gmtor,13.3,05"

constant client_enkey={'2','7','3','6','1','8','4','9','0','5'}
sequence client_dekey
client_dekey=repeat(0,10)

procedure client_dekey_init()
	integer pos
	pos=48
	for i=1 to 10 do
	   client_dekey[ (client_enkey[i]-48) +1] =pos
	   pos+=1
	end for
end procedure
client_dekey_init()


function serial_encrypt_keymap(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= client_enkey[(temp[i]-48)+1]
  end for	
  return st
end function

function serial_encrypt_client_xor(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= xor_bits(temp[i],client_key[pos])
  end for	
  return st
end function

function serial_encrypt_server_xor(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= xor_bits(temp[i],server_key[pos])
  	  pos+=1
  	  if pos>length(server_key) then
  	   pos=1
  	  end if
  end for	
  return st
end function

function serial_decrypt_keymap(sequence temp)
sequence st
integer pos
  pos=1
  st={}
  for i=1 to length(temp) do
  	  st&= client_dekey[(temp[i]-48)+1]
  	  pos+=1
  	  if pos>length(client_dekey) then
  	   pos=1
  	  end if
  end for	
  return st
end function

function serial_number(sequence temp)
sequence st
  st={}
  for i=1 to length(temp) do
    if temp[i]>='0' and temp[i]<='9' then
  	  st&= temp[i]
    end if	
  end for	
  return st
end function



function reg_get_serial_timestamp()
sequence data,pid
atom ttime
integer len

  data=serial_encrypt_client_xor(fromBase64(getText(textbox_serial)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 then
        return ttime
	  end if

  	end if
  	
    end if
  	
  end if		
end function


function reg_get_serial_timestamp2(sequence text)
sequence data,pid
atom ttime
integer len

  data=serial_encrypt_client_xor(fromBase64(text))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	  if equal(pid,product_id)=1 then
        return ttime
	  end if

  	end if
  	
    end if
  	
  end if		
end function


procedure reg_create_serial(sequence serial)
  integer fn
  sequence temp
  fn=open("reg.dat","r")
  if fn=-1 then
    fn=open("reg.dat","w")
    puts(fn,serial&"\n")
    setText(textbox_serial,serial)
    puts(fn,"serial key\n")
    close(fn)
  else
    temp=gets(fn)
    setText(textbox_serial,temp[1..length(temp)-1])
    close(fn)
  end if

end procedure

procedure reg_is_active()
sequence data,pid,text
atom ttime,ftime
integer len,fn


  --reg
   register1=1
	    register2=1
	    --setEnable(button_generate,0)
	      --)/(60*60*24))
	    setText(lable_message,"Botmaker, The only verified legitimate download mpgh.net. Registered ")
return
  --reg

  fn=open("reg.dat","r")

  if fn=-1 then
    setText(lable_message,"Botmaker,  The only verified legitimate download mpgh.net. Not Registered")
  	return
  end if

  text=gets(fn)

  data=serial_encrypt_server_xor(fromBase64(gets(fn)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
  	  data=data[1..(length(data)-4)]
  	  ftime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	

	  if equal(pid,product_id)=1 and ftime=reg_get_serial_timestamp2(text) and ttime<=ftime+((60*60*24)*30) and floor( (ttime-w32Func(xttime,{}))/((60*60)*24) )>=0 then
	    register1=1
	    register2=1
	    setEnable(button_generate,0)
	      --)/(60*60*24))
	    setText(lable_message,"Botmaker, The only verified legitimate download mpgh.net. Registered remaining days: "&sprint( floor( (ttime-w32Func(xttime,{}))/((60*60)*24) ) ) )
	    --puts(1,"feture unlocked\n")
	    close(fn)
	    return
	  end if

  	end if
  	
    end if
  	
  end if
	

  setText(lable_message,"Botmaker,  The only verified legitimate download mpgh.net. Not Registered")
end procedure


buildguid={}
if length(temp)<8 then
  puts(1,"unable to get serial error\n")	
else

buildguid=serial_number(temp)
product_id=serial_number(temp)

--puts(1,toBase64("testing base64 encoding poop"))
--puts(1,fromBase64(toBase64("testing base64 encoding poop")))
--puts(1,"tes")

temp=int_to_bytes(w32Func(xttime,{}))

reg_create_serial(toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ))

--setText(textbox_serial,toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) )

--puts(1,serial_encrypt_client_xor(  fromBase64( toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) ) ) )

reg_is_active()


end if  ---product id larger


--	    register1=1
--	    register2=1


function texted(sequence data)
  atom message,result
  integer inc,char
  sequence text
  message=allocate_string(data)
  result=w32Func(xrsa_public_key_encyrp,{message})
  inc=0

  text=""
  while 1 do
  	char=peek(result+inc)
  	
  	if char=0 then
  		exit
  	end if
  	if char!=10 then
  	  text&=char
  	
  	end if
  	inc+=1
  end while

  free(message)
  return text
end function

--integer fid
--fid=open("fid.txt","w")
--puts(1,texted())
--puts(fid,texted("shdbshdvsdbsdbs"))
--close(fid)

--?texted("shdbshdvsdbsdbs")

constant debug_mode=0

atom items_bitmap
items_bitmap = loadBitmapFromFile( "renders.bmp" )

integer running,request_teleport,intrade,spam_one_time,enable_move_to_target,enable_auto_login,connected,trade_done_flag
running=0
request_teleport=0
intrade=0
spam_one_time=0
enable_move_to_target=0
sequence current_trading_name
current_trading_name=""
trade_done_flag=0

if register1=1 and register2=1 then
  setTimer(Window1,1099,1000*8)
else
  setTimer(Window1,1099,1000*45)	
end if

enable_auto_login=0
--trade_completed=0
connected=0


sequence owner_name
integer owner_object_id
owner_name=""
owner_object_id=0


sequence server_list
server_list={
{"USWest","54.241.208.233"},    --54.241.208.233
{"USMidWest","54.80.67.112"},
{"EUWest","54.154.30.49"},--
{"USEast","54.224.68.81"},
{"AsiaSouthEast","54.255.15.39"},
{"USSouth","23.22.180.212"},
{"USSouthWest","54.219.44.205"},
{"EUEast","46.137.30.179"},
{"EUNorth","54.195.96.152"},
{"EUSouthWest","54.217.63.70"},
{"USEast3","54.226.214.216"},
{"USWest2","54.193.168.4"},
{"USMidWest2","50.17.143.165"},
{"USEast2","54.204.50.57"},
{"USNorthWest","50.18.24.120"},
{"AsiaEast","175.41.201.80"},
{"USSouth3","54.80.250.47"},
{"EUNorth2","54.216.200.98"},
{"EUWest2","54.216.27.65"},  --54.216.27.65
{"EUSouth","54.195.179.215"},
{"USSouth2","50.19.7.133"},
{"USWest3","54.241.223.240"}
}


sequence rotmg_buildversion
rotmg_buildversion="19.5.1"

setCtlSize(List1,150,400)
setCtlSize(List2,150,400)

for i=1 to length(item_ids) do
  addItem(List1,item_ids[i][2])	
  addItem(List2,item_ids[i][2])	
end for

for i=1 to length(server_list) do
  addItem(combox_serverlist,server_list[i][1])	
end for
setIndex(combox_serverlist,1)

integer fn
sequence con_ip_address,con_email,con_pass,con_owner,con_amount1,con_amount2
integer con_index1,con_index2

fn=open("config.txt","r")
--con_ip_address=gets(fn)
--con_ip_address=con_ip_address[1..length(con_ip_address)-1]
con_email=gets(fn)
con_email=con_email[1..length(con_email)-1]
setText(textbox_email,con_email)
con_pass=gets(fn)
con_pass=con_pass[1..length(con_pass)-1]
setText(textbox_password,con_pass)
con_owner=gets(fn)
con_owner=con_owner[1..length(con_owner)-1]
setText(textbox_owner_name,con_owner)
con_index1=real(gets(fn))
con_index2=real(gets(fn))
con_amount1=sprint(real(gets(fn)))
con_amount2=sprint(real(gets(fn)))
setText(textbox_amount1,con_amount1)
setText(textbox_amount2,con_amount2)
setText(textbox_target_x,sprint(real(gets(fn))))
setText(textbox_target_y,sprint(real(gets(fn))))
enable_move_to_target=real(gets(fn))
setCheck(checkbox_move_to_target,enable_move_to_target)
enable_auto_login=real(gets(fn))
setCheck(checkbox_auto_login,enable_auto_login)
setCheck(checkbox_can_tell_owner,real(gets(fn)))
setCheck(checkbox_sound_tradedone,real(gets(fn)))
setCheck(checkbox_message_mode,real(gets(fn)))
setIndex(combox_serverlist,real(gets(fn)))
setCheck(check_enable_custom_message,real(gets(fn)))
setText(textbox_chattime,sprint(real(gets(fn))))
setCheck(checkbox_showname,real(gets(fn)))

rotmg_buildversion=gets(fn)
rotmg_buildversion=rotmg_buildversion[1..length(rotmg_buildversion)-1]
setText(textbox_rotmg_build_version,rotmg_buildversion)

if register1=1 and register2=1 then
  setTimer(Window1,1099,1000*real(getText(textbox_chattime)))
else
  setText(textbox_chattime,sprint(45))
end if

close(fn)


sequence custom_message
object line
custom_message={}

fn=open("custom message.txt","r")
while 1 do
  line=gets(fn)
  if integer(line) then
  	exit
  end if
  if line[1]=10 then
  else
    custom_message=append(custom_message,line[1..length(line)-1])
    setText(textbox_custom_text,getText(textbox_custom_text)&line)
    --?getText(textbox_custom_text)
  end if

end while
close(fn)

--?length(custom_message)



  if isChecked(checkbox_message_mode)=0 then
  	setText(checkbox_message_mode,"Message Buying")
  else
    setText(checkbox_message_mode,"Message Selling")
  end if

setIndex(List1,con_index1)
setIndex(List2,con_index2)



sequence spam_message,spam_message2
integer spam_interval,spam_count
spam_message={}
spam_message2={}
spam_interval=1
spam_count=0


object junk
junk = {{},{}}
for j = 360 to 0 by -1 do
    junk[1] = append(junk[1], sin(j*PI/180) )
    junk[2] = append(junk[2], cos(j*PI/180) )
end for
constant sin_loTRUE2up = junk[1], cos_loTRUE2up = junk[2]

function point_distance(atom x1,atom y1 , atom x2, atom y2)
    atom x, y
    x = power(floor(x1) - floor(x2), 2)
    y = power(floor(y1) - floor(y2), 2)
    return sqrt(x + y)
end function

--targ.x += dist*Math.sin(Math.toRadians((90*gCli.index)+inca));
--		targ.y += dist*Math.cos(Math.toRadians((90*gCli.index)+inca));

constant space3dto2d=32
integer item_sell_id,item_sell_cost
integer item_buy_id,item_buy_cost
item_sell_id=0
item_buy_id=0
item_sell_cost=0
item_buy_cost=0

sequence item_sell_name
sequence item_buy_name
item_sell_name={}
item_buy_name={}

--for i=1 to length(item_ids) do
--  item_ids[i][2]

--end for

procedure centerwindow(integer win)
integer width,height,window_width,window_height
sequence size
    size=getCtlSize(win)
    window_width=size[1]
    window_height=size[2]
    width=w32Func(xGetSystemMetrics,{SM_CXSCREEN})
    height=w32Func(xGetSystemMetrics,{SM_CYSCREEN})
    setRect( win,floor((width/2))-floor((window_width/2)) ,floor((height/2))-floor((window_height/2))-32, window_width, window_height, 0 )
end procedure

--function rgb2( integer r, integer g, integer b )
--    return makecol(r,g,b)
--end function

sequence key_buffer
key_buffer={}

function remove_line(sequence string, integer line)
sequence temp
integer len
  len=length(string)
  if line=1 then
    return string[2..len]
  elsif line=len then
    return string[1..len-1]
  else
    temp=string[1..line-1]
    return temp&string[line+1..len]
  end if
end function

procedure key_add(integer scancode)
integer found
found=0
  for i=1 to length(key_buffer) do
    if key_buffer[i]=scancode then
      found=1
      exit
    end if
  end for
  if found=0 then
    key_buffer=append(key_buffer,scancode)
  end if
end procedure

procedure key_remove(integer scancode)
  for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       key_buffer=remove_line(key_buffer,i)
       exit
     end if
  end for
end procedure

function key_check(integer scancode)
   for i=1 to length(key_buffer) do
     if key_buffer[i]=scancode then
       return 1
     end if
  end for
  return 0
end function

constant window_titlebar_height = getSystemMetrics ( SM_CYCAPTION )
constant window_menu_height = getSystemMetrics ( SM_CYMENU )
constant window_hscrollbar_width = getSystemMetrics ( SM_CXVSCROLL )
constant window_vscrollbar_height = getSystemMetrics ( SM_CYVSCROLL )
constant window_border_width = getSystemMetrics ( SM_CXFRAME )
constant window_border_height = getSystemMetrics ( SM_CYFRAME )
constant window_toolbar_height = 33

constant window_all_height=window_titlebar_height+window_menu_height+window_toolbar_height+(getSystemMetrics ( SM_CYFRAME )*2)

function convert3dspaceto2d(atom v)
  sequence float
  integer haspoint,leftside,padleft,padright
  atom rightside
  haspoint=0

  float=sprint(v)
  for i=1 to length(float) do
  	if float[i]='.' then
  	  haspoint=1
  	  leftside=real(float[1..i-1])
  	  rightside=real("0."&float[i+1..length(float)])
  	end if
  end for

  if haspoint=1 then
    padleft=floor(space3dto2d*leftside)
  	padright=floor(space3dto2d*rightside)
  	return padleft+padright
  else
    return space3dto2d*v
  end if
end function


sequence map_data
integer map_width,map_height
map_width=255
map_height=255
map_data={}


--new main loop control

atom start_time
start_time=0
integer current_tick
current_tick=0

integer my_object_id
my_object_id=0

sequence my_position,my_name
my_position={}
sequence target_position
target_position={133,135}
sequence my_status
my_status={}
my_name={}
--end main loop control

--trading system
sequence my_items,my_items_selected,there_items,there_items_selected
my_items={}
there_items={}
my_items_selected=repeat(0,12)
there_items_selected=repeat(0,12)
integer trading_mode
trading_mode=0 --0 equals selling life for def, 1 equals selling def for life
--end trading system

sequence object_id_to_player_class
object_id_to_player_class=repeat(0,4000000) --2 million objects

constant player_constants={806,805,804,803,802,801,800,799,798,797,784,782,775,768}
sequence player_bitmap_offset
integer tmp
player_bitmap_offset=repeat(0,length(player_constants))
tmp=length(player_constants)

for i=1 to length(player_constants) do
  player_bitmap_offset[tmp]=(21*(i-1))+8
  tmp-=1
end for

include input_stream.ew
include output_stream.ew
include location.ew
include object_status.ew
include object_status_data.ew
include stat_data.ew
include tile.ew

include players.ew

constant inputstream = input_stream_new()
constant outputstream = output_stream_new()

integer first_update
sequence first_update_data
first_update=0
first_update_data={}
sequence update_state

update_state={0,0,0,0}

constant inputstream_update = input_stream_new()

constant xGetTickCount = registerw32Function(kernel32, "GetTickCount", {}, C_LONG)
constant xSleep = registerw32Procedure(kernel32, "Sleep", {C_LONG})

procedure usleep(integer v)
	w32Proc(xSleep,{v})
end procedure

function get_tick_count()
  return  w32Func(xGetTickCount,{})
end function

--public int currentTime() {
--		return (int) (System.currentTimeMillis() - startTime);
--	}

function current_time()
  return  w32Func(xGetTickCount,{})-start_time
end function




sequence send_buffer
send_buffer={}

global constant SM_ASYNC = #FFFF
atom hWndMainWindow
atom Server_sock
Server_sock=0

constant double_max_value=1.7976931348623157E308

function create_guest_guid_old()
  atom uid
  uid=	0.6176749197488145--+rand(1073741823)
  return uid*double_max_value	
end function

function create_guest_guid_java()
  integer fn,char
  sequence data
  fn=open("input.txt","w")
  start_time=get_tick_count()
  puts(fn,sprint(start_time))
  close(fn)
  if system_exec("guest.bat", 2) then
    puts(2, "failure!\n")
  end if
  fn=open("output.txt","rb")
  data=gets(fn)
  close(fn)
  return data
end function

function create_login_guid_java(sequence email,sequence pass)
  integer fn,char
  sequence data
  fn=open("input.txt","w")
  puts(fn,email&":"&pass)
  close(fn)
  --if system_exec("login.bat", 2) then
  --  puts(1, "failure!\n")
  --end if
  --if system_exec("crypto.exe tested asd", 2) then
  --  puts(1, "failure!\n")
  --end if
  fn=open("output.txt","rb")
  data=gets(fn)
  close(fn)
  for i=1 to length(data) do
  	if data[i]=' ' then
  	  data={data[1..i-1],data[i+1..length(data)]}
  	  exit	
  	end if
  end for
  return data
end function


procedure debug(sequence text)
  integer fn
  if debug_mode=1 then
  	fn=open("debug.txt","a")
    puts(fn, text)
  end if


  setText(console_output,text&getText(console_output))
  if debug_mode=1 then	
    close(fn)
  end if
end procedure
debug("Started\n")

sequence key1,key2

--these work
--key1 is for encrypting data to send to the client
key1={114,197,88,60,175,182,129,137,149,203,215,75,128}
--key2 is for decrypting data from the client
key2={49,31,128,105,20,81,199,27,9,161,58,42,110}

key1={114,197,88,60,175,182,129,137,149,205,215,75,128}
key2={49,31,128,105,20,81,199,29,9,161,58,42,110}

--311f80691451c71b09a13a2a6e
--311f80691451c71b09a13a2a6e
--((((("-----BEGIN PUBLIC KEY-----\n" + "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDEmgEmQcgLd0mvWqL6AKmhzj") + "JfZoAmZC0PUmG8K9CB1Ml68P00S3eU+TSL5aG8Mg3Tipvs02gC2veC10knRi7r") + "EsUwL8+h22EsjnpKZ/7K5YV9cefryTMnS0x4QGZbSkdPz/rLh0uGwk8Zu0cEKb") + "xQyvd3+pSmqZ5/ZQGaFjm9TQIDAQAB\n") + "-----END PUBLIC KEY-----");


--((((("-----BEGIN PUBLIC KEY-----\n" + "MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDCKFctVrhfF3m2Kes0FBL/JFeO") + "cmNg9eJz8k/hQy1kadD+XFUpluRqa//Uxp2s9W2qE0EoUCu59ugcf/p7lGuL99Uo") + "SGmQEynkBvZct+/M40L0E0rZ4BVgzLOJmIbXMp0J4PnPcb6VLZvxazGcmSfjauC7") + "F3yWYqUbZd/HCBtawwIDAQAB\n") + "-----END PUBLIC KEY-----");


puts(1,key1)
--finaly got rc4 encrption working 27/03/2013 --update streaming cipher working 03/05/2013

arcfour_init_encrypt(key1)
arcfour_init_encrypt2(key2)

-----------------------------write functions--------------------------------------

function writeutf(sequence data, sequence v)
  sequence s
   s=int_to_bytes(length(v))
   data&=s[2]&s[1]&v
   return data
end function

function writeint(sequence data ,atom v)
sequence s
   s=int_to_bytes(v)
   data&=s[4]&s[3]&s[2]&s[1]
   return data
end function

function writefloat(sequence data ,atom v)
sequence s
   s = atom_to_float32(v)
   data&=s[4]&s[3]&s[2]&s[1]
   return data
end function

function writebool(sequence data, integer b)
   data&=b
   return data
end function

function writeshort(sequence data ,atom v)
sequence s
   s=int_to_bytes(v)
   data&=s[2]&s[1]
   return data
end function

function writebyte(sequence data ,integer v)
   data&=v
   return data
end function

sequence packet_list
packet_list={}

procedure packet_ids_load2()
  object line
sequence buffer,buffer2
integer fn,pos

sequence key
pos=1
key="loop1234abcd"
buffer={}
buffer2={}

fn=open("packets enc.inf","rb")

while 1 do
  line=gets(fn)
  if integer(line) then
    exit
  end if
  buffer&=line
end while

close(fn)

--puts(1, "length "&sprint(length(buffer))&"\n" )

for i=1 to length(buffer) do
    buffer[i]=xor_bits(buffer[i], key[pos] )
    pos+=1
    if pos>length(key) then
      pos=1
    end if
end for

--puts(1, "length "&sprint(length(buffer))&"\n" )

--puts(1,buffer)

pos=1
for i=1 to length(buffer) do
  if buffer[i]=10 then
    buffer2=append(buffer2, buffer[pos..i] )
    pos=i+1
  end if
end for


for i=1 to length(buffer2) do
  --puts(1,buffer2[i])
  pos=match(" ",buffer2[i])
  packet_list=append(packet_list,{buffer2[i][1..pos-1], real(buffer2[i][pos+2..length(buffer2[i])]) })	
end for

--fn=open("packets.inf","r")

--while 1 do
--  line=gets(fn)
--  if integer(line) then
--    exit
--  end if
--  buffer=append(buffer,line)
--  pos=match(" ",line)
--  packet_list=append(packet_list,{line[1..pos-1], real(line[pos+2..length(line)]) })
  --puts(1,line[1..pos-1]&"\n")
  --puts(1,sprint(real(line[pos+2..length(line)]))&"\n")
--end while
	
end procedure
packet_ids_load2()

procedure packet_ids_load()
  object line
sequence buffer,buffer2
integer fn,pos

sequence key
pos=1
key="loop1234abcd"
buffer={}
buffer2={}

fn=open("packets.inf","r")

while 1 do
  line=gets(fn)
  if integer(line) then
    exit
  end if
  buffer=append(buffer,line)
  pos=match(" ",line)
  packet_list=append(packet_list,{line[1..pos-1], real(line[pos+2..length(line)]) })
  puts(1,line[1..pos-1]&"\n")
  puts(1,sprint(real(line[pos+2..length(line)]))&"\n")
end while
close(fn)	
end procedure
--packet_ids_load()


function packet_name_to_id(sequence name)
  for i=1 to length(packet_list) do
    if equal(packet_list[i][1],name) then
      return packet_list[i][2]
    end if

  end for
end function



global constant fail_packet = packet_name_to_id("FAILURE")
global constant create_suc_packet=packet_name_to_id("CREATE_SUCCESS")
global constant create_packet=packet_name_to_id("CREATE")
global constant move_packet=packet_name_to_id("MOVE")

global constant useportal_packet=packet_name_to_id("USEPORTAL")
global constant invresult_packet=packet_name_to_id("INVRESULT")
global constant ping_packet=packet_name_to_id("PING")

global constant global_notification_packet=packet_name_to_id("GLOBAL_NOTIFICATION")
global constant updateatt_packet=packet_name_to_id("UPDATEACK")
global constant tradedone_packet=packet_name_to_id("TRADEDONE")
global constant shoot_packet=packet_name_to_id("SHOOT")

global constant gotoack_packet=packet_name_to_id("GOTOACK")
global constant pong_packet=packet_name_to_id("PONG")
global constant hello_packet=packet_name_to_id("HELLO")
global constant nameresult_packet=packet_name_to_id("NAMERESULT")
global constant requesttrade_packet=packet_name_to_id("REQUESTTRADE")
global constant tradechanged_packet=packet_name_to_id("TRADECHANGED")
global constant text_packet=packet_name_to_id("TEXT")
global constant update_packet=packet_name_to_id("UPDATE")

global constant reconnect_packet=packet_name_to_id("RECONNECT")
global constant play_sound_packet=packet_name_to_id("PLAYSOUND")
global constant load_packet=packet_name_to_id("LOAD")
global constant accountlist_packet=packet_name_to_id("ACCOUNTLIST")
global constant goto_packet=packet_name_to_id("GOTO")
global constant show_effect_packet=packet_name_to_id("SHOW_EFFECT")
global constant mapinfo_packet=packet_name_to_id("MAPINFO")
global constant traderequest_packet=packet_name_to_id("TRADEREQUESTED")
global constant new_tick_packet=packet_name_to_id("NEW_TICK")
global constant notification_packet=packet_name_to_id("NOTIFICATION")
global constant tradestart_packet=packet_name_to_id("TRADESTART")
global constant playertext_packet=packet_name_to_id("PLAYERTEXT")
global constant allyshoot_packet=packet_name_to_id("ALLYSHOOT")
global constant clientstat_packet=packet_name_to_id("CLIENTSTAT")
global constant invitedtoguild_packet=packet_name_to_id("INVITEDTOGUILD")
global constant choosename_packet=packet_name_to_id("CHOOSENAME")



global sequence packet_names,packet_read_id,packet_read_used
packet_names=repeat("",110)
packet_read_id=repeat(-1,110)
packet_read_used=repeat(-1,110)

packet_names[ fail_packet+1 ]= "failed"
packet_names[ useportal_packet+1 ]= "useportal"
packet_names[ invresult_packet+1 ] ="invresult"
packet_names[ ping_packet+1 ]= "ping"
packet_names[ global_notification_packet+1 ]= "global notifcaion"
packet_names[ tradedone_packet+1 ]= "tradedone"
packet_names[ shoot_packet+1 ]= "shoot"
packet_names[ hello_packet+1 ]= "hello"
packet_names[ requesttrade_packet+1 ]= "requesttrade"
packet_names[ tradechanged_packet+1 ]= "tradechanged"
packet_names[ text_packet+1 ]= "text"
packet_names[ update_packet+1 ]= "update"
packet_names[ create_suc_packet+1 ]= "create sucs"
packet_names[ create_packet+1 ]= "create packet"
packet_names[ reconnect_packet+1 ]= "reconnect"
packet_names[ play_sound_packet+1 ]= "play sound"
packet_names[ load_packet+1 ]= "load packet"
packet_names[ accountlist_packet+1 ]= "accountlist"
packet_names[ goto_packet+1 ]= "goto packet"
packet_names[ show_effect_packet+1 ]= "show effect"
packet_names[ mapinfo_packet+1 ]= "mapinfo"
packet_names[ traderequest_packet+1 ]= "traderequest"
packet_names[ new_tick_packet+1 ]= "new tick"
packet_names[ notification_packet+1 ]= "notification"
packet_names[ tradestart_packet+1 ]= "tradestart"
packet_names[ playertext_packet+1 ]= "playertext"
packet_names[ allyshoot_packet+1 ]= "allyshoot"
packet_names[ clientstat_packet+1 ]= "clientstat"
packet_names[ invitedtoguild_packet+1 ]= "invitedtoguild"



--realm packets

global constant questobjid_packet =packet_name_to_id("QUESTOBJID")
global constant damage_packet =packet_name_to_id("DAMAGE")
global constant shootmulti_packet=packet_name_to_id("SHOOTMULTI")
global constant shootack_packet=packet_name_to_id("SHOOTACK")
global constant death_packet=packet_name_to_id("DEATH")
global constant aoe_packet=packet_name_to_id("AOE")
global constant aoeack_packet=packet_name_to_id("AOEACK")


packet_names[ questobjid_packet+1] ="questobjid"
packet_names[ damage_packet+1] ="questobjid"
packet_names[ shootmulti_packet+1] ="shootmulti"
packet_names[ shootack_packet+1] ="shootack"
packet_names[ death_packet+1] ="death"
packet_names[ aoe_packet+1] ="aoe"
packet_names[ aoeack_packet+1] ="aoeack"

constant tradeaccepted_packet=packet_name_to_id("TRADEACCEPTED")
constant canceltrade_packet =packet_name_to_id("CANCELTRADE")
constant changetrade_packet =packet_name_to_id("CHANGETRADE")
constant accepttrade_packet =packet_name_to_id("ACCEPTTRADE")

sequence minimap_data
constant minimap_width=256,minimap_height=256
minimap_data={}
atom minimap_bitmap
 minimap_bitmap = loadBitmapFromFile( "minimap.bmp" )

procedure minimap_load_data()
  integer fn,char,x,y
  fn=open("mapdata.txt","rb")

  for i=1 to minimap_height do
    minimap_data=append(minimap_data,repeat(0,minimap_width))
  end for

  x=1
  y=1
  while 1 do
  	char=getc(fn)
  	if char=-1 then--end of file
      exit
  	end if
  	minimap_data[y][x]=char
  	x+=1
  	if x>minimap_width then
  	  x=1
  	  y+=1
  	end if
  end while
	
  close(fn)
end procedure
--minimap_load_data()

procedure minimap_render()
--rgb()
--121
--58

  for y=1 to minimap_height do
  	for x=1 to minimap_width do
  	  if minimap_data[y][x]=122 then
  	  	setPixel( minimap_buffer, x-1, y-1, Blue )
  	  elsif minimap_data[y][x]=121 then
  	    setPixel( minimap_buffer, x-1, y-1, rgb(128,128,128) )
  	  elsif minimap_data[y][x]=58 then
  	  	setPixel( minimap_buffer, x-1, y-1, rgb(200,200,200) )
  	  elsif minimap_data[y][x]=0 then
  	    setPixel( minimap_buffer, x-1, y-1, Black )
  	  elsif minimap_data[y][x]=96 then
  	    setPixel( minimap_buffer, x-1, y-1, Black )
  	  elsif minimap_data[y][x]=35 then
  	    setPixel( minimap_buffer, x-1, y-1, rgb(0,200,0) )
  	  elsif minimap_data[y][x]=254 then
  	    setPixel( minimap_buffer, x-1, y-1, Red )
  	  end if
    end for
  end for

end procedure
--minimap_render()



procedure draw_my_items()
integer xx,yy
    xx=0
    yy=10

	for i=1 to length(my_status) do
	  if length(my_status[i]) then
	  	
	
	  if my_status[i][1]>=8 and my_status[i][1]<=19 then
	    if my_status[i][2]=4294967295 then
	
	  	     bitBlt( backbuffer,  -- copy to TheWindow
                  xx, yy,     -- put at {10,10} in TheWindow
                  items_bitmap,        -- copy from loaded bitmap
                  item_data[1][4], item_data[1][5],        -- upper left hand corner is {0,0}
                  40, 40,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
	    else
	  	for j=1 to length(item_data) do
	  	  if item_data[j][1]=my_status[i][2] then
	  	     bitBlt( backbuffer,  -- copy to TheWindow
                  xx, yy,     -- put at {10,10} in TheWindow
                  items_bitmap,        -- copy from loaded bitmap
                  item_data[j][4], item_data[j][5],        -- upper left hand corner is {0,0}
                  40, 40,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
	  	  	exit
	  	  end if
	  	end for
	  	end if
	  	xx+=40
	  	if xx>=(40*4) then
	  	  xx=0
	  	  yy+=40
	  	end if
	  end if
	  end if
	end for
	
	
   copyBlt( Window1, 460, 0, backbuffer )
   --?666
end procedure

function hello_packet_write()
  sequence data,temp
  data={}
  data=writeutf(data,rotmg_buildversion) --build version
  --data=writeint(data,20934212)
  data=writeint(data,-2) --game id
  --data=writeutf(data,"XRU8xQGLzCLaQR2BMOVLE9aPLggIPbNcig/rA1Wyi+KnlfIO02VXKpDEMO7hjscFXccRGOnTHpKoLkbuo2OXrU0wGWzJLsNGSf007Ga71Eu6VCZ61dNIzm71qKl9B5z7ERceI/JFk9NQ7RvmdQpK1s+bB9qAsVWGwhlECBA4EU0=")--create_guest_guid_java())--"PAP6RSeDHDRLpNVO4dw7oMsZS/6gIdnSFj9LHjI/YL8Al61XUPAxMtx5d/fYzmdwbgdRed6X1pHcVKUX16q59wvlzVouQZeim0P8HwXxbuMWwS+Bf9YFUANoriQzjMV/PlNAc17GfxkVQAn2LNYSV3m+BfEAwE6/WUNtyIYZJWI=") --guid
  --data=writeutf(data,"Z+TWxbDpdKsNAKn358XZHOTI4nZEI4/oCrOB7CI8uDYdgWmXN4DKwfCcONgurW+xrGEWoLzviOyg5yRYxaeV55N7OB75OSGtslcs4Tjc8oNRILQG5wofw2YH+MG/jWshUfxC8yQBWJ/Akn+j1ROuS4+CEgjklZjLGC/Oc0EVgDQ=")

   --login deatils



  data=writeutf(data,texted(con_email))
  data=writeint(data,floor((rand(65536)+1)* #3B9ACA00))
  data=writeutf(data,texted(con_pass))

  data=writeint(data,floor((rand(65536)+1)* #3B9ACA00))
  data=writeutf(data,"")


  --temp=create_login_guid_java(con_email,con_pass)
  --data=writeutf(data,temp[1])
  --data=writeutf(data,temp[2])
  --puts(1,temp[1]&"\n")
  --puts(1,temp[2]&"\n")

  --guest accoun login
  --data=writeutf(data,create_guest_guid_java())
  --data=writeutf(data,"") --pass


  data=writeint(data,-1) --key time
  data=writeshort(data,0)
  --data=writebyte(data,0) --
  data=writeint(data,0)  --jd length
  --data=writebyte(data,0) -- jd bytes

  data=writeutf(data,"") --pk
  data=writeutf(data,"rotmg") --tq
  data=writeutf(data,"") --h
  data=writeutf(data,"rotmg") --platforum

  data=writeutf(data,"") --unknow

  --data=writeint(data,34329)

  temp=reverse(int_to_bytes(length(data)+5)) &hello_packet

  data=arcfour_encrypt_block2(data)
  return temp & data
end function

procedure playertext_packet_write(sequence text)
sequence data,temp
  data={}
	data=writeutf(data,text)

  temp=reverse(int_to_bytes(length(data)+5)) &playertext_packet

  data=arcfour_encrypt_block2(data)
  send_buffer=append(send_buffer,{temp&data})
end procedure

--integer map_width,map_height
sequence map_name

procedure mapinfo_packet_read(integer packet_length)
  object temp
  sequence data
  integer count
  count=0
	map_width=input_stream_readint(inputstream)
	count+=4
	map_height=input_stream_readint(inputstream)
	count+=4
	map_name=input_stream_readutf(inputstream)
	count+=length(map_name)+2
	temp=input_stream_readint(inputstream)
	count+=4
	temp=input_stream_readint(inputstream)
	count+=4
	temp=input_stream_readbool(inputstream)
	count+=1
	temp=input_stream_readbool(inputstream)
	count+=1
	
    --debug(input_stream_slice(inputstream,1, (packet_length-5)-count )&"\n")
    --need to slice the correct amount from the map info pack
    input_stream_set(inputstream, input_stream_slice(inputstream, ((packet_length-5)-count)+1, input_stream_length(inputstream) ) )
	
    map_data={}
    for i=1 to map_height do
      map_data=append(map_data,repeat(0,map_width))	
    end for
--init to zero
	
end procedure

function create_packet_write()
  sequence data,temp
  data={}

  data=writeshort(data,782)
  data=writeshort(data,0)

  temp=reverse(int_to_bytes(length(data)+5)) &create_packet

  data=arcfour_encrypt_block2(data)

  return temp & data
end function

integer char_id,objecttype_id
char_id=1
objecttype_id=0

function load_packet_write()
  sequence data,temp
  data={}

  data=writeint(data,char_id)
  data=writebyte(data,0)

  temp=reverse(int_to_bytes(length(data)+5)) &load_packet

  data=arcfour_encrypt_block2(data)
  return temp & data
end function

function useportal_packet_write(integer num)
  sequence data,temp
  data={}

  data=writeint(data,num)

  temp=reverse(int_to_bytes(length(data)+5)) &useportal_packet

  data=arcfour_encrypt_block2(data)
  return temp & data
end function


procedure create_suc_packet_read()
  object res
  debug("create_suc\n")
  my_object_id=input_stream_readint(inputstream)
  debug(sprint(my_object_id)&"\n")
  --?res
  res=input_stream_readint(inputstream)
  debug(sprint(res)&"\n")
  --?res
end procedure

sequence update_drop_list
update_drop_list={}

procedure update_packet_read()
  object res
  integer size,object_type,index
  integer found
  sequence temp,temp2,stats

  --new code optimizeation
  integer object_id
  sequence position
  integer class

  --
  integer fn
  atom direction

  --puts(1,"updated\n")
  size=input_stream_readshort(inputstream)

  --puts(1,"tile size "&sprint(size)&"\n")
  if size!=0 then --tiles
    --fn=open("tiles.txt","w")
  	for i=0 to size-1 do
  	  res=tile_new_from_input(inputstream)
  	  res=tile_get(res)
  	  map_data[res[2]][res[1]]=res[3]
  	  --puts(fn,sprint(tile_get_type(res))&"\n")
  	
    end for
    --for yy=1 to 255 do
      --for xx=1 to 255 do
      	--puts(fn,sprint(map_data[yy])&"\n")
      --end for	
    --end for
    --close(fn)

  end if

  if register1=0 or register2=0 then
    --abort(0)
  end if

  size=input_stream_readshort(inputstream)
  --puts(1,"newobj size "&sprint(size)&"\n")
  if size!=0 then --new obj
  	for i=0 to size-1 do
  	  res=object_status_new_from_input(inputstream)
  	  temp=object_status_get(res)
  	  --?temp[1]--object type
  	  found=0
  	  for j=1 to length(player_constants) do
  	  	if temp[1]=player_constants[j] then
  	  	  found=j
  	  	end if
  	  end for
  	  if found!=0 then
  	  	
  	  --my object code--
  	  temp=object_status_data_get(temp[2])
  	  --puts(1,sprint(temp[1])&"\n")
  	  if temp[1]=my_object_id then
  	  	debug("my status updated  2\n")
  	  	--?i
  	  	--?size

  	  	--repaintRect( Window1, 560, 1, 560+160, 200 )
  	  	my_position=location_get(temp[2])
  	  	?my_position
  	  	
        --direction=((315+rand(45))*PI/180)--((180+rand(180))*PI/180)
        --target_position[1]=my_position[1]+4*sin(direction)
        --target_position[2]=my_position[2]+4*cos(direction)
        --?target_position[1]
        --?target_position[2]
  	  	--my_position_real=my_position
  	  	my_status={}
  	  	for j=1 to length(temp[3]) do
  	  	  temp2=stat_data_get(temp[3][j])
  	  	  --?temp2
  	  	  if temp2[1]=31 then
  	  	  --	puts(1,temp2[3]&"\n")
  	  	  --	?j
  	  	    --puts(1,temp2[3])
  	  	    my_name=temp2[3]
  	  	    setText(label_bot_name,"Bot Name: " &my_name)
  	  	  end if
  	  	  my_status=append(my_status,temp2)
  	  	end for
  	  	draw_my_items()
  	  	--?length(my_status)
  	  	--?my_status
  	  	--?location_get(temp[2])
  	  end if
  	  -- end my object code
  	
  	  stats={}
  	  temp=object_status_data_get(temp[2])
  	  for j=1 to length(temp[3]) do
  	  	temp2=stat_data_get(temp[3][j])
	  	if temp2[1]=31 then
  	  	   if equal(owner_name,temp2[3])=1 then
  	  	   	 owner_object_id=temp[1]
  	  	   end if
  	  	end if
  	  	stats=append(stats,temp2)
  	  end for
  	
      --player_list=append(player_list,{temp[1],stats,location_get(temp[2]),found})
      position=location_get(temp[2])
      object_id_to_player_class[temp[1]]=player_new(temp[1],stats,position,found,{convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2])},stats[29][3])

  	  object_status_delete(res)
  	
      end if

  	end for
  end if

  size=input_stream_readshort(inputstream)
  --puts(1,"drop size "&sprint(size)&"\n")

  for i=0 to size-1 do
  	 res=input_stream_readint(inputstream)
  	 update_drop_list&=res
     --new optimize code
     if object_id_to_player_class[res]!=0 then --object to be deleted is a player
       player_delete(object_id_to_player_class[res])
       object_id_to_player_class[res]=0
     end if

     if res=owner_object_id then
     	owner_object_id=0
     end if
     --end new optimized code
  	
  end for

    --UPDATEATT = 11;
  temp=reverse(int_to_bytes(length("")+5)) &updateatt_packet
  --write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp})
  --res=WsockSendData(Server_sock,temp)

end procedure


procedure global_notification_read()
   object res
    --puts(1,"global_notification \n")
	res=input_stream_readint(inputstream)
	res=input_stream_readutf(inputstream)
end procedure

procedure accountlist_read()
  object res

  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
  for i=0 to res-1 do
  	res=input_stream_readutf(inputstream)
  end for

  res=input_stream_readint(inputstream)
end procedure

procedure show_effect_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=input_stream_readint(inputstream)
end procedure

procedure allyshoot_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
  res=input_stream_readint(inputstream)
end procedure

procedure notification_read()
  object res
  res=input_stream_readint(inputstream)
  res=input_stream_readutf(inputstream)
  res=input_stream_readint(inputstream)
end procedure

procedure disconnect()
   debug("disconnect called\n")
   for i=1 to length(send_buffer) do
     --res=WsockSendData(Server_sock,send_buffer[i][1])
   end for
   send_buffer={}
   sleep(1)
   WsockCloseSocket(Server_sock)

   --
   sleep(1)
   arcfour_init_encrypt(key1)
   arcfour_init_encrypt2(key2)
   input_stream_set(inputstream, "")

   my_position={}
   my_status={}
   my_name={}

   my_items={}
   there_items={}
   my_items_selected=repeat(0,12)
   there_items_selected=repeat(0,12)
   trading_mode=0
   current_trading_name=""


   --need to deallocate this correctly
   player_class_list={}
   my_object_id=0
   owner_object_id=0
   my_status={}
   player_freelist_delete()
   object_id_to_player_class=repeat(0,4000000) --2 million objects
end procedure


function random_message()
sequence temp
  temp={}
	for i=1 to 4 do
	  temp&=rand(4)+40
	end for
	return temp
end function

procedure new_tick_read()
  integer size,tick_id
  object res
  sequence temp,write,temp2,stats,temp_stat

  --new code optimizeation
  integer object_id
  sequence position
  integer class,count

  tick_id=input_stream_readint(inputstream)
  res=input_stream_readint(inputstream)
  size=input_stream_readshort(inputstream)

  for i=0 to size-1 do
  	res=object_status_data_new_from_input(inputstream)
  	
    temp=object_status_data_get(res)

    --new optimize code
    object_id=temp[1]
    if object_id_to_player_class[object_id]!=0 then --object to be updated is a player
      stats=player_stats_get(object_id_to_player_class[object_id])
      --?length(stats)
      for j=1 to length(temp[3]) do
        --if length(temp[3][j]) then --new 12/07/2013
        	

      	temp_stat=stat_data_get(temp[3][j])
      	for k=1 to length(stats) do
      	  if length(stats[k]) then
      	  	
      	
      	  if temp_stat[1]=stats[k][1] then
      	  	stats[k]=temp_stat
      	  	exit
      	  end if
      	
          end if
	
	   end for
      	
      --	end if --end new 12/07/2013
      	
      end for

      if object_id=my_object_id then
      	my_status=stats
      end if

      position=location_get(temp[2])
      --if my_object_id=object_id then
      --	my_position=position
      --end if
      player_update( object_id_to_player_class[object_id],stats,position, {convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2]) } )
    end if
    --end new optimized code

  	object_status_data_delete(res)
  end for

  --if size!=0 then --cause a bug that cost me 2-3 hours to track down
  	current_tick=tick_id
  --end if

  write=""
  write=writeint(write,current_tick) --tick id
  --?current_tick
  --?tick_id
  write=writeint(write,current_time()) --time
  --position

  --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])
  if enable_move_to_target=1 then --
  	
  --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])
  if length(my_position) and point_distance(my_position[1],my_position[2],target_position[1],target_position[2])>1 then
    --?point_distance(my_position[1],my_position[2],target_position[1],target_position[2])

  	if my_position[1]<target_position[1] then
  	  my_position[1]+=0.10
  	else
	   my_position[1]-=0.10
  	end if
  	
    if my_position[2]<target_position[2] then
  	  my_position[2]+=0.10
  	else
	   my_position[2]-=0.10
  	end if
  end if
  --?my_position
  --?target_position
  end if


  --?my_position

  if object_id_to_player_class[my_object_id]!=0 then
    count=0
    stats=player_stats_get(object_id_to_player_class[my_object_id])
    --?stats
    --?stats[9] --first equipment slot
    for i=13 to 13+8 do
      if stats[i][2]=item_sell_id then
    	count+=1
      end if	
    end for

    if count<item_sell_cost and running=1 then
      --?1
      if isChecked(checkbox_can_tell_owner)=1 then
        playertext_packet_write("/tell "&owner_name&" sold the items, bot @"&my_name)
      end if
      debug("incorrect item to be sold or the amount of item to be sold is incorrect, or the bot has sold the items\n")
      debug("Stopped trading\n")
      --Beep( MB_OK )
      running=0
      setText(pushbutton_trading,"Start Trading")
      draw_my_items()
      --disconnect()
    else

      if count>=item_sell_cost and running=0 then
        --?2
     	running=1
     	if isChecked(checkbox_can_tell_owner)=1 then
          playertext_packet_write("/tell "&owner_name&" Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name)
        end if
     	setText(pushbutton_trading,"Stop Trading")
      	draw_my_items()
      end if
    end if
    --sleep(10)
  end if

  if length(my_position) then

  write=writefloat(write,my_position[1])
  write=writefloat(write,my_position[2])

  write=writeshort(write,0)
  --Move = 7;
  temp=reverse(int_to_bytes(length(write)+5)) &move_packet
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
  else
    write=writefloat(write,134)
  write=writefloat(write,142)

  write=writeshort(write,0)
  --Move = 7;
  temp=reverse(int_to_bytes(length(write)+5)) &move_packet
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
  end if

  if request_teleport=1 then
  	request_teleport=0
  	if owner_object_id!=0 then
  	write=""
  	write=writeint(write,owner_object_id)
    temp=reverse(int_to_bytes(length(write)+5)) &49
    write=arcfour_encrypt_block2(write)
    --send_buffer=append(send_buffer,{temp&write})
    end if
  end if

  --spam_message={"spam bot testing 00","spam bot testing 01"}
  if trading_mode=0 and running=1 and intrade=0 and spam_one_time=1 then
    if isChecked(checkbox_showname)=1 then
      playertext_packet_write(spam_message[spam_interval]&" @"&my_name)
    else
      --playertext_packet_write(random_message()&"   "&spam_message[spam_interval]&"   "&random_message())--&" @"&my_name)
       playertext_packet_write(spam_message[spam_interval])--&" @"&my_name)
    end if
  	
    spam_interval+=1
    if spam_interval>length(spam_message) then
  	  spam_interval=1
    end if
    spam_one_time=0
  end if

end procedure

procedure text_read()
  object res
  atom object_id
  res=input_stream_readutf(inputstream)
  object_id=input_stream_readint(inputstream)
  res=input_stream_readint(inputstream)
  res=input_stream_readbyte(inputstream)
  res=input_stream_readutf(inputstream)
  res=input_stream_readutf(inputstream)
  --puts(1,res&"\n")
  if object_id!=4294967295 and object_id_to_player_class[object_id]!=0 then
  	 player_message_set(object_id_to_player_class[object_id],{res,33*12})
  end if

  --if equal(lower(res),lower("connecting to uswest")) then
  --	puts(1,"found us west server\n")
  --end if
  --puts(1,res&"\n")

  res=input_stream_readutf(inputstream)

  --	this.name_ = badi.readUTF(); // UTF
	--	this.objectId_ = badi.readInt(); // Int
	--	this.numStars_ = badi.readInt(); // Int
	--	this.bubbleTime_ = badi.readUnsignedByte(); // UnsignedByte
	--	this.recipient_ = badi.readUTF(); // UTF
	--	this.text_ = badi.readUTF(); // UTF
	--	this.cleanText_ = badi.readUTF(); // UTF
end procedure

atom ping_start
ping_start=0

procedure ping_read()
  object res
  sequence write,temp

  if ping_start=0 then
  	ping_start=time()
  end if
  --?(time()-ping_start)/2

  ping_start=time()

  res=input_stream_readint(inputstream)

  write=""
  --?res
  write=writeint(write,res) --serial
  write=writeint(write,current_time()) --time

  --PONG = 16;
  temp=reverse(int_to_bytes(length(write)+5)) &pong_packet
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})

end procedure

procedure goto_packet_read()
  object res
  sequence write,temp
  res=input_stream_readint(inputstream)
  if res=my_object_id then
    debug("yes set myposition\n")
    res=location_new_from_input(inputstream)
    my_position[1]=location_get_x(res)
    my_position[2]=location_get_y(res)
    setText(textbox_target_x,sprint(floor(my_position[1])))
    setText(textbox_target_y,sprint(floor(my_position[2])))
    target_position[1]=floor(my_position[1])
    target_position[2]=floor(my_position[2])
  else
    res=location_new_from_input(inputstream)
  end if

  location_delete(res)

  write=""
  write=writeint(write,current_time()) --time

  temp=reverse(int_to_bytes(length(write)+5)) &gotoack_packet
  write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp&write})
end procedure

procedure shoot_packet_read()
  object res
  res=input_stream_readbyte(inputstream)
  res=input_stream_readint(inputstream)
  if res=my_object_id then
  	debug("shoot_packet_testing")
  end if
  res=input_stream_readint(inputstream)
  res=location_new_from_input(inputstream)
  location_delete(res)
  res=input_stream_readint(inputstream)
  res=input_stream_readshort(inputstream)
end procedure

procedure play_sound_read()
  object res
  res=input_stream_readint(inputstream)
  res=input_stream_readbyte(inputstream)
end procedure

procedure traderequest_packet_read()
  object res
  sequence data,temp
  data={}
  res=input_stream_readutf(inputstream)
  debug("trade requested "&res&"\n")

  --automaticly trade upon request
  if running=1 then
    playertext_packet_write("/tell "&res&" Please select "&sprint(item_buy_cost)&" "&item_buy_name)
  	data=writeutf(data,res)
    temp=reverse(int_to_bytes(length(data)+5)) &requesttrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
  else
    if equal(res,owner_name) then
      data=writeutf(data,res)
      temp=reverse(int_to_bytes(length(data)+5)) &requesttrade_packet
      data=arcfour_encrypt_block2(data)
      send_buffer=append(send_buffer,{temp&data})
    end if
  end if

end procedure

procedure check_there_item()
  integer count
  sequence temp
  count=0
  for i=5 to 12 do
  	if there_items[i][1]=item_buy_id then
  	  count+=1
  	end if
  end for	
  if count>=item_buy_cost then
  else
   if intrade=1 then
     debug("Trade incorrect items canceled\n")
     temp=reverse(int_to_bytes(length("")+5)) &canceltrade_packet-- CANCELTRADE:int = 25;
     send_buffer=append(send_buffer,{temp})
     intrade=0
    end if
  end if
end procedure

procedure tradestart_packet_read()
  object res
  integer size
  atom item,bt,eq,included
  sequence data,temp,choose
  size=input_stream_readshort(inputstream)
  my_items={}
  my_items_selected=repeat(0,12)
  for i=0 to size-1 do
    item=input_stream_readint(inputstream)
    bt=input_stream_readint(inputstream)
    eq=input_stream_readbool(inputstream)
    included=input_stream_readbool(inputstream)
	my_items=append(my_items,{item,bt,eq,included})
  end for

  --puts(1,"my items\n")
  --?my_items
  if debug_mode=1 then
  debug("trade start my_items\n")
  for i=1 to length(my_items) do
  	debug(sprint(my_items[i][1])&",")
  end for
  debug("\n")
  end if

  --fix a 18/05/2013 scam items bug
  res=input_stream_readutf(inputstream)
  current_trading_name=res
  --fix a 18/05/2013

  size=input_stream_readshort(inputstream)
  there_items={}
  there_items_selected=repeat(0,12)
  for i=0 to size-1 do
    item=input_stream_readint(inputstream)
    bt=input_stream_readint(inputstream)
    eq=input_stream_readbool(inputstream)
    included=input_stream_readbool(inputstream)
    there_items=append(there_items,{item,bt,eq,included})
  end for
  --puts(1,"there items\n")
  --?there_items
  if debug_mode=1 then
  debug("trade start there items\n")
  for i=1 to length(there_items) do
  	debug(sprint(there_items[i][1])&",")
  end for
  debug("\n")
  end if

  intrade=1

  if running=1 then
    if equal(current_trading_name,owner_name)=0  then
      check_there_item()--new version 03
    end if
  end if


  if equal(current_trading_name,owner_name) then --new version 5
    data={}
    choose={0,0,0,0,isChecked(checkbox_slot1),isChecked(checkbox_slot2),isChecked(checkbox_slot3),isChecked(checkbox_slot4),
    isChecked(checkbox_slot5),isChecked(checkbox_slot6),isChecked(checkbox_slot7),isChecked(checkbox_slot8)}
   --my item first
         data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) &changetrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & accepttrade_packet--  ACCEPTTRADE:int = 63;
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})	

  end if

  setTimer(Window1,3000,1000*22) --22 second delay before closing the window

end procedure



procedure tradedone_packet_read()
  object res
  integer done,count
  done=0
  count=0
  res=input_stream_readint(inputstream)
  res=input_stream_readutf(inputstream)
  for i=1 to length(res) do
  	if res[i]='.' then
  	  for j=i+1 to length(res) do
  	  	if res[j]='"' then
  	  	  --puts(1,"found "&res[i+1..j-1]&"\n")
	      if equal("trade_successful",res[i+1..j-1])=1 then
	      	--trading_mode=not(trading_mode)
	      	trade_done_flag=1
	      	done=1
	      end if
  	  	  exit
  	  	end if
  	  end for	
  	  exit
  	end if
  end for

  intrade=0

  if done=1 then --new version 03

    if isChecked(checkbox_sound_tradedone)=1 then
      VOID = playSound("button-3.wav")	
    end if

    --repaintWindow(Window1)
    --repaintRect( Window1, 560, 1, 560+160, 200 )
  	--playertext_packet_write("/tell "&owner_name&" sold the items, bot @"&my_name)
  end if

  debug("tradedone "&res&"\n")
end procedure


procedure changetrade_packet_write(integer count)
  sequence data,temp,choose
  integer tradedone,sel
  data={}

  choose={0,0,0,0,isChecked(checkbox_slot1),isChecked(checkbox_slot2),isChecked(checkbox_slot3),isChecked(checkbox_slot4),
    isChecked(checkbox_slot5),isChecked(checkbox_slot6),isChecked(checkbox_slot7),isChecked(checkbox_slot8)}

  --puts(1,owner_name&"\n")
  --puts(1,current_trading_name&"\n")
  if running=1 then

  if equal(current_trading_name,owner_name) then

        data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) & changetrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & accepttrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})	
  else

  	tradedone=0
    sel=0
    if trading_mode=0 then
      if count>=item_buy_cost then
        for i=5 to 12 do
          if my_items[i][1]=item_sell_id then
            sel+=1
            my_items_selected[i]=1
            if sel>=item_sell_cost then
          	  tradedone=1
      	      exit
            end if
          end if
        end for
      else
        for i=5 to 12 do
      	  my_items_selected[i]=0
        end for
      end if
    end if

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,my_items_selected[i])
    end for
     if debug_mode=1 then
    debug("change pack write\n")
    debug(sprint(my_items_selected)&"\n")
    end if

    temp=reverse(int_to_bytes(length(data)+5)) & changetrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
    --ACCEPTTRADE = 57;
    if tradedone=1 then
  	  data=""
  	  data=writeshort(data,12)
      for i=1 to 12 do
  	    data=writebool(data,my_items_selected[i])
      end for
     data=writeshort(data,12)
     for i=1 to 12 do
  	   data=writebool(data,there_items_selected[i])
     end for
      temp=reverse(int_to_bytes(length(data)+5)) & accepttrade_packet
      data=arcfour_encrypt_block2(data)
      send_buffer=append(send_buffer,{temp&data})
    end if

  end if
  elsif running=0 and equal(current_trading_name,owner_name) then
    	
    data=writeshort(data,12)
    for i=1 to 12 do
      if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if

      end if
  	
    end for

    temp=reverse(int_to_bytes(length(data)+5)) & changetrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})

  	data=""
  	data=writeshort(data,12)
  	
    for i=1 to 12 do
  	  if i<5 then
      	data=writebool(data,0)
      else
        if my_items[i][1]!=4294967295 and choose[i]=1 then
          data=writebool(data,1)
	    else
	      data=writebool(data,0)
        end if
      end if
    end for

    data=writeshort(data,12)
    for i=1 to 12 do
  	  data=writebool(data,there_items_selected[i])
    end for
    temp=reverse(int_to_bytes(length(data)+5)) & accepttrade_packet
    data=arcfour_encrypt_block2(data)
    send_buffer=append(send_buffer,{temp&data})
  end if

end procedure

procedure tradechanged_packet_read()
  integer size,count
  object res
  sequence items
  items={}
  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    items&=res
  end for
  there_items_selected=items

  if debug_mode=1 then
  debug("there_items_selected\n")
  debug(sprint(there_items_selected)&"\n")
  end if
  --?items



  if trading_mode=0 then --selling life for 6 def
    count=0
  	for i=5 to 12 do
  	  if there_items[i][1]=item_buy_id and	there_items_selected[i]=1 then
  	  	count+=1
  	  end if
  	end for
  	changetrade_packet_write(count)
  end if

end procedure


procedure clientstat_packet_read()
  object res
  res=input_stream_readutf(inputstream)
  debug(res&"\n")
  res=input_stream_readint(inputstream)

end procedure

procedure reconnect_packet_read()
  object res
  integer size
  res=input_stream_readutf(inputstream)
  puts(1,"name "&res&"\n")
  res=input_stream_readutf(inputstream)
  puts(1,"host"&res&"\n")
  res=input_stream_readint(inputstream)
  puts(1,"port ")
  ?res
  puts(1,"\n")
  res=input_stream_readint(inputstream)
  puts(1,"game id")
  ?res
  puts(1,"\n")
  res=input_stream_readint(inputstream)
  puts(1,"key time")
  ?res
  size=input_stream_readshort(inputstream)
  ?size
  res=input_stream_readfully(inputstream,size)
  ?res
  --this.name_ = badi.readUTF(); // UTF
  --this.host_ = badi.readUTF(); // UTF
	--	this.port_ = badi.readInt(); // Int
	--	this.gameId_ = badi.readInt(); // Int
	--	this.keyTime_ = badi.readInt(); // Int
	--	short size = badi.readShort();
	--	this.key_ = new byte[size];
	--	badi.readFully(key_);

end procedure

procedure tradeaccepted_packet_read()
  --dummy function
  integer size,count
  object res
  sequence items
  items={}
  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    --items&=res
  end for

  size=input_stream_readshort(inputstream)
  for i=0 to size-1 do
    res=input_stream_readbool(inputstream)
    --items&=res
  end for

end procedure

procedure invitedtoguild_packet_read()
  object res
  res=input_stream_readutf(inputstream)	
  res=input_stream_readutf(inputstream)	
end procedure


procedure connect_to_server()
	integer iwork, port
  sequence swork,ip

  port = 2050

  iwork = WsockInit()
  if iwork = -1 then -- WinSock failed
    iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    abort(99)
  end if

  hWndMainWindow = getHandle(Window1)
  --blocking connect, might need to make this none blocking
  --puts(1,server_list[getIndex(combox_serverlist)][1]&"\n")
  --?getIndex(combox_serverlist)
  --Server_sock=Wsock_new("107.22.218.252", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))


  Server_sock=Wsock_new(server_list[getIndex(combox_serverlist)][2], 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  puts(1,server_list[getIndex(combox_serverlist)][2]&"\n")
  --Server_sock=Wsock_new("50.18.113.133", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  --Server_sock=Wsock_new("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

end procedure


procedure handle_send_fail()
    connected=0
    sleep(2)
    first_update=0
  	disconnect()
    connect_to_server()
end procedure




--update_packet_read_backprocess(inputstream_update)

function update_packet_read_backprocess(integer inputstream)--basicly need to process this a bit at a time over 20 seconds
  object res
  integer size,object_type,index
  integer found
  sequence temp,temp2,stats

  --new code optimizeation
  integer object_id
  sequence position
  integer class

  --
  integer fn
  atom direction

  --puts(1,"updated\n")
  if update_state[1]=0 then
    size=input_stream_readshort(inputstream)	
    update_state[1]=size

    --puts(1,"start count\n")
    --?size
  else
   size=update_state[1]

  end if
  --size=input_stream_readshort(inputstream)

  --puts(1,"tile size "&sprint(size)&"\n")
  if size!=0  then --tiles
    --fn=open("tiles.txt","w")
  	for i=0 to size-1 do
  	  res=tile_new_from_input(inputstream)
  	  res=tile_get(res)
  	  --map_data[res[2]][res[1]]=res[3]
  	  --puts(fn,sprint(tile_get_type(res))&"\n")
  	  update_state[1]=size-(i+1)
      update_state[4]+=1
      if update_state[4]>40 then
      	update_state[4]=0
      	--puts(1,"end size\n")
      	--?update_state[1]
      	return 0
      end if
    end for
    --for yy=1 to 255 do
      --for xx=1 to 255 do
      	--puts(fn,sprint(map_data[yy])&"\n")
      --end for	
    --end for
    --close(fn)

  end if
  update_state[1]=-1

  if update_state[2]=0 then
    size=input_stream_readshort(inputstream)
    update_state[2]=size
  else
    size=update_state[2]
  end if

  --size=input_stream_readshort(inputstream)
  --puts(1,"newobj size "&sprint(size)&"\n")
  if size!=0  then --new obj
  	for i=0 to size-1 do
  	  --puts(1,"crap\n")
  	  --?i
  	  res=object_status_new_from_input(inputstream)
  	  temp=object_status_get(res)
  	  --?temp[1]--object type
  	  found=0
  	  for j=1 to length(player_constants) do
  	  	if temp[1]=player_constants[j] then
  	  	  found=j
  	  	end if
  	  end for
  	  if found!=0 then
  	  	
  	  --my object code--
  	  temp=object_status_data_get(temp[2])
  	  --puts(1,sprint(temp[1])&"\n")
  	  if temp[1]=my_object_id then
  	  	debug("my status updated\n")

  	  	--repaintRect( Window1, 560, 1, 560+160, 200 )
  	  	my_position=location_get(temp[2])
  	  	
        --direction=((315+rand(45))*PI/180)--((180+rand(180))*PI/180)
        --target_position[1]=my_position[1]+4*sin(direction)
        --target_position[2]=my_position[2]+4*cos(direction)
        --?target_position[1]
        --?target_position[2]
  	  	--my_position_real=my_position
  	  	my_status={}
  	  	for j=1 to length(temp[3]) do
  	  	  temp2=stat_data_get(temp[3][j])
  	  	  --?temp2
  	  	  if temp2[1]=31 then
  	  	  --	puts(1,temp2[3]&"\n")
  	  	  --	?j
  	  	    my_name=temp2[3]
  	  	    setText(label_bot_name,"Bot Name: " &my_name)
  	  	  end if
  	  	  my_status=append(my_status,temp2)
  	  	end for
  	  	draw_my_items()
  	  	--?length(my_status)
  	  	--?my_status
  	  	--?location_get(temp[2])
  	  end if
  	  -- end my object code
  	
  	  stats={}
  	  temp=object_status_data_get(temp[2])
  	  for j=1 to length(temp[3]) do
  	  	temp2=stat_data_get(temp[3][j])
	  	if temp2[1]=31 then
  	  	   if equal(owner_name,temp2[3])=1 then
  	  	   	 owner_object_id=temp[1]
  	  	   end if
  	  	end if
  	  	stats=append(stats,temp2)
  	  end for
  	
      --player_list=append(player_list,{temp[1],stats,location_get(temp[2]),found})
      position=location_get(temp[2])
      object_id_to_player_class[temp[1]]=player_new(temp[1],stats,position,found,{convert3dspaceto2d(position[1]),convert3dspaceto2d(position[2])},stats[29][3])

  	  object_status_delete(res)
  	
      end if

      update_state[2]=size-(i+1)
      update_state[4]+=1
      if update_state[4]>20 then
      	update_state[4]=0
      	return 0
      end if

  	end for
  end if
   update_state[2]=-1

  --there a error somewhere with the above code think it size-(i+1) not sure without testing
  --size=input_stream_readshort(inputstream)
  --puts(1,"drop size "&sprint(size)&"\n")

  --for i=0 to size-1 do
  	-- res=input_stream_readint(inputstream)
  	
     --new optimize code
    -- if object_id_to_player_class[res]!=0 then --object to be deleted is a player
      -- player_delete(object_id_to_player_class[res])
      -- object_id_to_player_class[res]=0
     --end if
     --end new optimized code
  	
 --- end for


  for i=1 to length(update_drop_list) do
     --new optimize code
     if object_id_to_player_class[update_drop_list[i]]!=0 then --object to be deleted is a player
       player_delete(object_id_to_player_class[update_drop_list[i]])
       object_id_to_player_class[update_drop_list[i]]=0
     end if
  end for
  update_drop_list={}

  return 1 --done
end function


procedure process_update_packet(sequence data)
object object_type,object_id,stats,res
atom x,y,statdata_size,size
integer loc,inputstream,statdata_type
  --puts(1,"process_update_packet\n")
  object_type=int_to_bytes(objecttype_id)
  object_id=int_to_bytes(my_object_id)

  loc=match({object_type[2], object_type[1], object_id[4],object_id[3],object_id[2],object_id[1]}, data)
  if loc=0 then
  	puts(1,"a serious error as happend\n")
  	return
  end if

  debug("my stats updated\n")
  --puts(1,"asd\n")

  inputstream = input_stream_new()
  input_stream_set(inputstream, data[loc..length(data)])	




      object_type=input_stream_readshort(inputstream)
      object_id=input_stream_readint(inputstream)
      x=input_stream_readfloat(inputstream)
      y=input_stream_readfloat(inputstream)

      my_position={x,y}
      --?x
      --?y

      statdata_size=input_stream_readshort(inputstream)
      stats=repeat({},100) --the most number of stats a object can have

      my_status={}
      --?statdata_size
      for j=1 to statdata_size do
      	statdata_type=input_stream_readbyte(inputstream)
        if statdata_type=31 or statdata_type=62 or statdata_type=82 or statdata_type=38 or statdata_type=54  then

          stats[statdata_type+1]={statdata_type,0,input_stream_readutf(inputstream)}

          if statdata_type=31 then
            my_name=stats[statdata_type+1][3]
  	  	    setText(label_bot_name,"Bot Name: " &my_name)
          end if

        else
          stats[statdata_type+1]={statdata_type,input_stream_readint(inputstream),0}
        end if

      end for

      my_status=stats
      draw_my_items()

      --?stats
      --782 wizard
      if object_type=806 or object_type=805 or object_type=804 or object_type=803 or object_type=802 or object_type=801 or object_type=800
      or object_type=799 or object_type=798 or object_type=797 or object_type=784 or object_type=782 or object_type=775 or object_type=768 then
       -- integer object_id, sequence stats, sequence position, integer class,sequence position2d,sequence name
	    --object_id_to_player_class[object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"")
	
	    --autolootbots_list[client_list[client][client_data]][7][object_id]=player_new(object_id,stats,{x,y},object_type,{0,0},"",client)
	
       object_id_to_player_class[object_id]=player_new(temp[1],stats,{x,y},object_type,{0,0},my_name)
       --global function player_new(integer object_id, sequence stats, sequence position, integer class,sequence position2d,sequence name

	    --?autolootbots_list[client_list[client][client_data]][7][object_id]
	
	    if object_id=my_object_id then
	      --autolootbots_list[client_list[client][client_data]][3]=x
	      --autolootbots_list[client_list[client][client_data]][4]=y
	    end if
      end if

  --size=input_stream_readshort(inputstream)
  --puts(1,"drop size "&sprint(size)&"\n")

--  for i=0 to size-1 do
  	 --res=input_stream_readint(inputstream)

  --end for

    --UPDATEATT = 11;
  temp=reverse(int_to_bytes(length("")+5)) &updateatt_packet
  --write=arcfour_encrypt_block2(write)
  send_buffer=append(send_buffer,{temp})


  --?object_type
  --?object_id
  --for i=1 to length(data)-6 do
 -- 	if data[i]=object_type[2] and data[i+1]=object_type[1] then
  --	  if data[i+2]=object_id[4] and data[i+3]=object_id[3] and data[i+4]=object_id[2] and data[i+5]=object_id[1] then
 -- 		puts(1,"found\n")
  --	  end if
 -- 	end if
 -- end for
  --?length(data)
  	--my guessing is the bytes at the end of the packet are my object
  	--update shouldent ever destory anything for the first update packet
  	-- noew i just need to read them quickly
end procedure



procedure read_packet()
  integer packet_id,packet_len,temp
  sequence data,fail_message,write
  object res

  --puts(1,"location class size "&sprint(location_classsize())&"\n")
  --puts(1,"object_status class size "&sprint(object_status_classsize())&"\n")
  --puts(1,"object_status_data class size "&sprint(object_status_data_classsize())&"\n")
  --puts(1,"stat_data class size "&sprint(stat_data_classsize())&"\n")
  --puts(1,"tile class size "&sprint(tile_classsize())&"\n")

  --puts(1,"size of  player_class_list "&sprint(length(player_class_list))&"\n")
  while 1 do


  if input_stream_length(inputstream)>5 and input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
  else
    exit
  end if

   for i=1 to length(send_buffer) do
     temp=WsockSendData(Server_sock,send_buffer[i][1])
     if temp!=length(send_buffer[i][1]) then
       if temp=-1 then
         debug("sending error socket error\n")
         handle_send_fail()
         return
         --abort(0)
       else
	     debug("sending error sent: "&sprint(temp)&" total length: "&sprint(send_buffer[i][1])&"\n")
	     handle_send_fail()
	     return
	     --abort(0)
       end if
     end if
   end for
   send_buffer={}


  packet_id=input_stream_peek(inputstream,5)
  packet_len=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} )
	
  puts(1,"packet id: "&packet_names[packet_id+1]&"\n")
  --?packet_id

  if input_stream_length(inputstream)>5 then
  	data=arcfour_decrypt_block(input_stream_slice(inputstream,6,packet_len))
  	
  	input_stream_set(inputstream, input_stream_slice(inputstream,packet_len+1, input_stream_length(inputstream) ) )
  	if packet_id=update_packet and first_update=0 then
  	  first_update=1
  	  --update_state={0,0,0,0}
  	  first_update_data=data
  	  --process_update_packet(data)
  	  --input_stream_set( inputstream_update, data)
  	   --input_stream_set(inputstream, data&input_stream_get(inputstream))
  	else
  	  input_stream_set(inputstream, data&input_stream_get(inputstream))
  	end if
  	--input_stream_set(inputstream, data&input_stream_get(inputstream))
  	
  end if

  if packet_id=fail_packet then
    debug("fail\n")
  	debug(sprint(input_stream_readint(inputstream))&"\n")
  	fail_message=input_stream_readutf(inputstream)
  	debug(fail_message&"\n")
  	if length(fail_message)>6 then
  	  if fail_message[1]='A' and fail_message[2]='c' then
  	  	--account
  	  	--puts(1,"accouct in use found \n")
  	  	--sleep(2)
  	  	disconnect()
        connect_to_server()
  	  end if	
  	end if
  elsif packet_id=ping_packet then
    ping_read()
  elsif packet_id=tradedone_packet then
    tradedone_packet_read()
  elsif packet_id=shoot_packet then
    shoot_packet_read()
  elsif packet_id=global_notification_packet then
    global_notification_read()
  elsif packet_id=play_sound_packet then
    play_sound_read()
  elsif packet_id=create_suc_packet then
    create_suc_packet_read()
  elsif packet_id=  tradeaccepted_packet then
    tradeaccepted_packet_read()
  elsif packet_id=tradechanged_packet then
    tradechanged_packet_read()
  elsif packet_id=accountlist_packet then
    accountlist_read()
  elsif packet_id=goto_packet then
    goto_packet_read()
  elsif packet_id= show_effect_packet then
    show_effect_read()
  elsif packet_id= text_packet then
    text_read()
  elsif packet_id=reconnect_packet then
    reconnect_packet_read()
  elsif packet_id=update_packet then
    --puts(1,"send_buffer\n")
    --?length(send_buffer)
    if first_update=1 then
      --write=reverse(int_to_bytes(length("")+5)) &11
      --send_buffer=append(send_buffer,{write})
      first_update=2
      debug("first update started\n")
      process_update_packet(data)
      --setTimer(Window1,4000,1000)
      --update_packet_read()
    else
	  update_packet_read()
	end if
	
  elsif packet_id= new_tick_packet then
    new_tick_read()
  elsif packet_id=tradestart_packet then
    tradestart_packet_read()
  elsif packet_id= traderequest_packet then
    traderequest_packet_read()
  elsif packet_id=  notification_packet then
     notification_read()
  elsif packet_id=mapinfo_packet then
  	mapinfo_packet_read(packet_len)
  elsif packet_id=	allyshoot_packet then
    allyshoot_read()
  elsif packet_id=clientstat_packet then
    clientstat_packet_read()
  elsif packet_id=invitedtoguild_packet then
    invitedtoguild_packet_read()
  else
    debug(sprint(packet_id)&"\n")
    debug("unknow packet\n")
    sleep(100)
  end if

  end while

    for i=1 to length(send_buffer) do
     temp=WsockSendData(Server_sock,send_buffer[i][1])
     if temp!=length(send_buffer[i][1]) then
       if temp=-1 then
         debug("sending error socket error\n")
         handle_send_fail()
         return
       else
	     debug("sending error sent: "&sprint(temp)&" total length: "&sprint(send_buffer[i][1])&"\n")
	     handle_send_fail()
	     return
       end if
     end if
   end for
   send_buffer={}


end procedure

procedure processServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork
  object    owork,junk
  sequence  newIP,swork,rx,tx
  sequence  data,temp

  action = lo_word(arg2)
  sock = arg1

  if action=FD_CONNECT then
    connected=1
  	debug("connected\n")
  	temp=hello_packet_write()
  	--puts(1,"send hello packet\n")
  	iwork=WsockSendData(sock,temp)
  	--?iwork
  	--?length(temp)
  	--iwork=WsockSendData(sock,create_packet_write())
  	--puts(1,"send load packet\n")
  	
  	temp=load_packet_write()
  	iwork=WsockSendData(sock,temp)
  	
  	--?iwork
  	--?length(temp)
  elsif action = FD_READ then
    rx = ""
    owork = WsockReadData_1024(sock,1024)
    --owork = WsockReadData(sock,1)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData_1024(sock,1024)
      --owork = WsockReadData(sock,1)
    end while
    if length(rx) > 0 then
      --puts(1,"packet recived\n")
      input_stream_append(inputstream,rx)

      if input_stream_length(inputstream)>5 then
        --puts(1,"packet length "&sprint(bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)})) &"  : actual len:"&sprint(input_stream_length(inputstream)) &"\n" )
        --puts(1,"packet id:"&sprint(input_stream_peek(inputstream,5))&"\n")

        if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          read_packet()	
        end if

      end if

    end if
  elsif action = FD_CLOSE then
     debug("server closed\n")
     WsockCloseSocket(sock)
     connected=0
     if enable_auto_login=1 then
       sleep(2)
       first_update=0
  	   disconnect()
       connect_to_server()
     end if
     --setTimer(Window1,1002,1000*60)
  end if
end procedure



-------------------------------------web code to create a new account----------------------------------------------

global constant SM_ASYNC2 = #FFFD
atom webserver_sock
webserver_sock=0
sequence getbuffer,accountemail,accountpassword,accounts
getbuffer={}
accounts={}

accountemail=""
accountpassword=""


procedure connect_to_webserver()
  integer iwork, port
  sequence swork,ip

  port = 80
  webserver_sock=Wsock_new("realmofthemadgod.appspot.com", port , hWndMainWindow, SM_ASYNC2,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  --webserver_sock=Wsock_new("74.125.25.141", port , hWndMainWindow, SM_ASYNC2,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
   --74.125.25.141
 --?1234
end procedure


function http_respond2(sequence data)
sequence sh	
sh ="" -- Server header

    -- Server return header
    sh &= "POST /char/list HTTP/1.1\n"
    sh &= "Host: realmofthemadgod.appspot.com\n"
    sh &= "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:21.0) Gecko/20100101 Firefox/21.0\n"
    sh &= "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8"
    sh &= "Accept-Language: en-gb,en;q=0.5\n"
    --sh &= "Accept-Encoding: gzip, deflate\n"
    sh &= "Connection: keep-alive\n"
    sh &= "Content-Type: application/x-www-form-urlencoded\n"
    sh &= sprintf("Content-Length: %d\n",{length(data)})

    return sh & 13 & 10 & data
end function

--<Success/>
--"<Error>Error.emailAlreadyUsed</Error>"


--integer count22
--count22=0

procedure processWebServerMessage(atom hWnd, atom arg1, atom arg2)
  atom      index, newsock
  integer   action, sock, iwork, fn,pos
  object    owork,junk,ret
  sequence  newIP,swork,rx,tx
  sequence  data,temp

  --xml data

  action = lo_word(arg2)
  sock = arg1
  --?1
  if action=FD_CONNECT then
     --?1
     getbuffer={}

     temp=""
     for i=1 to length(con_email) do
        if con_email[i]='+' then
          temp&='%'--%2B
          temp&='2'
          temp&='B'
        else
	     temp&=con_email[i]
        end if
     	
     end for

     --?123
     iwork=WsockSendData(webserver_sock,http_respond2("guid="&temp&"&ignore=6373&password="&con_pass))

  elsif action = FD_READ then
    rx = ""
    owork = WsockReadData(sock,1)
    while sequence(owork) do
      rx = rx & owork
      owork = WsockReadData(sock,1)
    end while

    if length(rx) > 0 then
      getbuffer&=rx

      --?rx
      --?3
      --count22+=1
      --puts(1,"count22")
      --?count22
      --puts(1,rx)

      pos=match("<Error>Account credentials not valid</Error>",getbuffer)
      if pos!=0 then

       	ret = message_box("Account credentials not valid","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
       	return
      end if

      if equal(getbuffer[length(getbuffer)-7..length(getbuffer)],"</Chars>") then

        pos=match("<Account><Name>",getbuffer)
        if pos!=0 then
          --puts(1,getbuffer[pos+15..pos+24]&"\n")
          for i=pos+15 to length(getbuffer) do
            if getbuffer[i]='<' then
          	  puts(1,getbuffer[pos+15..i-1]&"\n")	
          	  exit
            end if
          end for
        end if

        pos=match("nextCharId=",getbuffer)
        if pos!=0 then
          --puts(1,getbuffer[pos+12..pos+14]&"\n")
          for i=pos+12 to length(getbuffer) do
            if getbuffer[i]='"' then
          	  puts(1,getbuffer[pos+12..i-1]&"\n")	
          	  exit
            end if
          end for
        end if



        pos=match("ObjectType>",getbuffer)
        if pos!=0 then
          --puts(1,getbuffer[pos+9..pos+10]&"\n")
          for i=pos+11 to length(getbuffer) do
            if getbuffer[i]='<' then
          	  puts(1,getbuffer[pos+11..i-1]&"\n")
	          objecttype_id=real(getbuffer[pos+11..i-1])
          	  exit
            end if
          end for
          --?client_new(email_part1&"+"&sprint(count)&email_part2, password, "176.34.195.206", 0, char_id )
          --client_list[length(client_list)][client_created]=1
        else  --char as been killed and does not exesit
          puts(1,"char type does not \n")
        end if

        pos=match("Char id=",getbuffer)
        if pos!=0 then
          --puts(1,getbuffer[pos+9..pos+10]&"\n")
          for i=pos+9 to length(getbuffer) do
            if getbuffer[i]='"' then
          	  puts(1,getbuffer[pos+9..i-1]&"\n")
	          char_id=real(getbuffer[pos+9..i-1])
          	  exit
            end if
          end for
          --?client_new(email_part1&"+"&sprint(count)&email_part2, password, "176.34.195.206", 0, char_id )
          --client_list[length(client_list)][client_created]=1
          --?3
          connect_to_server()
        else  --char as been killed and does not exesit
          puts(1,"char as been killed and does not exesit\n")
        end if


      end if --fully return char list xml

      --puts(1,"len \n")
      --?length(getbuffer)


    end if
  elsif action = FD_CLOSE then
     WsockCloseSocket(sock)
  end if
end procedure
--------------------------------------------------------------------------------
procedure Window1_onClose (integer self, integer event, sequence params)--params is ()
  running=0
  WsockCloseSocket(Server_sock)
  --returnValue(-1)

end procedure
setHandler( Window1, w32HClose, routine_id("Window1_onClose"))
--------------------------------------------------------------------------------
procedure Window1_onEvent (integer self, integer event, sequence params)--params is ( int iMsg, atom wParm, atom lParm )
  if params[1] = SM_ASYNC then
	processServerMessage(hWndMainWindow,params[2],params[3])
  elsif params[1] = SM_ASYNC2 then
  	processWebServerMessage(hWndMainWindow,params[2],params[3])
  end if
end procedure
setHandler( Window1, w32HEvent, routine_id("Window1_onEvent"))
--------------------------------------------------------------------------------
procedure Window1_onKeyDown (integer self, integer event, sequence params)--params is ( atom scanCode, atom shift )
  key_add(params[1])
  ?1
end procedure
setHandler( Window1, w32HKeyDown, routine_id("Window1_onKeyDown"))
--------------------------------------------------------------------------------
procedure Window1_onKeyUp (integer self, integer event, sequence params)--params is ( int scanCode, int shift )
  key_remove(params[1])
end procedure
setHandler( Window1, w32HKeyUp, routine_id("Window1_onKeyUp"))
--------------------------------------------------------------------------------
procedure Window1_onOpen (integer self, integer event, sequence params)--params is ()
  integer iwork, port
  sequence swork,ip

  port = 2050

  iwork = WsockInit()
  if iwork = -1 then -- WinSock failed
    iwork = message_box("WSockInit() failed!","Error",MB_TASKMODAL + MB_ICONSTOP + MB_OK)
    abort(99)
  end if


  hWndMainWindow = getHandle(Window1)

  --blocking connect, might need to make this none blocking

  --Server_sock=Wsock_new(con_ip_address, 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  --Server_sock=Wsock_new("50.18.113.133", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

  --Server_sock=Wsock_new("127.0.0.1", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))

  --Server_sock=WsockSocket(AF_INET,SOCK_STREAM)

  --if WSAAsyncSelect(Server_sock,hWndMainWindow,SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))!=0 then
  --	puts(1,"WSAAsyncSelect error\n")
  --end if

  --ip=WsockHostInfo("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com")
  --puts(1,ip[2])

  --?WsockConnectAsync(Server_sock,2050,ip[2])

  --Server = WsockListenAsync(port, hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_ACCEPT,FD_CLOSE,FD_WRITE}))

  --if Server_sock = SOCKET_ERROR then  -- WinSock failed
  --  iwork = message_box("WsockListenAsync() failed!","Error",MB_TASKMODAL+MB_ICONSTOP+MB_OK)
  --  abort(99)
  --end if


end procedure
setHandler( Window1, w32HOpen, routine_id("Window1_onOpen"))
--------------------------------------------------------------------------------
procedure Window1_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
  --draw_my_items()
end procedure
setHandler( Window1, w32HPaint, routine_id("Window1_onPaint"))
--------------------------------------------------------------------------------
procedure Window1_onTimer (integer self, integer event, sequence params)--params is ( int timerId)
sequence temp
integer scan,scan2,scan3
  if params[1]=1001 then
     scan=KeyState(hotkey1_scancode)
     scan2=KeyState(hotkey2_scancode)
     scan3=KeyState(50)
    if scan<0 and scan2<0 and hotkey_1=0 then--hide all
      hotkey_1=1
      if isChecked(checkbox_hide) then
        showWindow(Window1, SW_HIDE)
      end if
    end if

    if scan<0 and scan3<0 and hotkey_2=0 then--show all
      hotkey_2=1
      if isChecked(checkbox_hide) then
      	showWindow(Window1, SW_RESTORE)
      end if

    end if

    if hotkey_1=1 and scan2>=0 then
      hotkey_1=0	
    end if

    if hotkey_2=1 and scan3>=0 then
      hotkey_2=0	
    end if

  elsif params[1]=1002 then
  	Server_sock=Wsock_new("ec2-176-34-195-206.eu-west-1.compute.amazonaws.com", 2050 , hWndMainWindow, SM_ASYNC,or_all({FD_READ,FD_CLOSE,FD_CONNECT}))
  elsif params[1]=1099 then
  	spam_one_time=1
  elsif params[1]=2000 then
  	--if input_stream_length(inputstream)>5 then
     --   if input_stream_length(inputstream)>=bytes_to_int( {input_stream_peek(inputstream,4),input_stream_peek(inputstream,3),input_stream_peek(inputstream,2),input_stream_peek(inputstream,1)} ) then
          --read_packet()	
      --  end if
     -- end if
  elsif params[1]=3000 then
    --new version 03
    if intrade=1 then
      debug("Trade timeout cancel\n")
      temp=reverse(int_to_bytes(length("")+5)) &1 --CANCELTRADE = 1;
      send_buffer=append(send_buffer,{temp})
      intrade=0

    end if
    killTimer(Window1,3000)
  elsif params[1]=4000 then
    return
    killTimer(Window1,4000)
    if update_packet_read_backprocess(inputstream_update)=1 then
      killTimer(Window1,4000)
    end if
    --?input_stream_length(inputstream_update)
  end if
end procedure
setHandler( Window1, w32HTimer, routine_id("Window1_onTimer"))
--------------------------------------------------------------------------------
procedure PushButton64_onClick (integer self, integer event, sequence params)--params is ()
  if register1=1 and register2=1 then
    openWindow(Window4,Modal)
  end if
end procedure
setHandler( PushButton64, w32HClick, routine_id("PushButton64_onClick"))
--------------------------------------------------------------------------------
procedure checkbox_message_mode_onClick (integer self, integer event, sequence params)--params is ()
  if isChecked(checkbox_message_mode)=0 then
  	setText(checkbox_message_mode,"Message Buying")
  else
    setText(checkbox_message_mode,"Message Selling")
  end if

end procedure
setHandler( checkbox_message_mode, w32HClick, routine_id("checkbox_message_mode_onClick"))
--------------------------------------------------------------------------------
procedure PushButton51_onClick (integer self, integer event, sequence params)--params is ()
--sequence temp
  --temp=int_to_bytes(w32Func(xttime,{}))
  --setText(textbox_serial,toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) )
  openWindow(Window3,Modal)
end procedure
setHandler( PushButton51, w32HClick, routine_id("PushButton51_onClick"))
--------------------------------------------------------------------------------
procedure PushButton9_onClick (integer self, integer event, sequence params)--params is ()
  sequence item_short_sell_name,item_short_buy_name
  item_short_sell_name=""
  item_short_buy_name=""

 if register1=0 or register2=0 then
    --return
 end if


  rotmg_buildversion=getText(textbox_rotmg_build_version)

  con_email=getText(textbox_email)
  con_pass=getText(textbox_password)
  item_sell_name=getItem( List1, getIndex(List1) )
  item_buy_name=getItem( List2, getIndex(List2) )

  item_sell_cost=real(getText(textbox_amount1))
  item_buy_cost=real(getText(textbox_amount2))

  for i=1 to length(item_ids) do
    if equal(item_sell_name,item_ids[i][2])=1 then
      item_sell_id=item_ids[i][1]
      item_short_sell_name=item_ids[i][2]
    end if
    if equal(item_buy_name,item_ids[i][2])=1 then
      item_buy_id=item_ids[i][1]
      item_short_buy_name=item_ids[i][2]
    end if
  end for

  owner_name=getText(textbox_owner_name)

  target_position[1]=real(getText(textbox_target_x))
  target_position[2]=real(getText(textbox_target_y))
  --?target_position[1]
  --?target_position[2]

  enable_move_to_target=isChecked(checkbox_move_to_target)

  enable_auto_login=isChecked(checkbox_auto_login)

  if isChecked(checkbox_message_mode)=1 then
   spam_message={"Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name,
   "Selling> "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name}
   --spam_message=lower({"S "&sprint(item_sell_cost)&" "&item_short_sell_name&" For "&sprint(item_buy_cost)&" "&item_short_buy_name,
   --"S> "&sprint(item_sell_cost)&" "&item_short_sell_name&" For "&sprint(item_buy_cost)&" "&item_short_buy_name})
  else
   spam_message={"Buying "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name,
   "Buying> "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name}

   --spam_message=lower({"B "&sprint(item_buy_cost)&" "&item_short_buy_name&" For "&sprint(item_sell_cost)&" "&item_short_sell_name,
   --"B> "&sprint(item_buy_cost)&" "&item_short_buy_name&" For "&sprint(item_sell_cost)&" "&item_short_sell_name})
  end if

  if isChecked(check_enable_custom_message)=1 and register1=1 and register2=1 then
  	spam_message=custom_message
  end if

  --connect_to_server()
  connect_to_webserver()
end procedure
setHandler( PushButton9, w32HClick, routine_id("PushButton9_onClick"))
--------------------------------------------------------------------------------
procedure pushbutton_trading_onClick (integer self, integer event, sequence params)--params is ()

sequence item_short_sell_name,item_short_buy_name
  item_short_sell_name=""
  item_short_buy_name=""

    if register1=0 or register2=0 then
      --return
    end if

    running=not(running)
    intrade=0


    if running=0 then
      debug("Stoped Trading\n")
      setText(pushbutton_trading,"Start Trading")
    elsif running=1 then
      debug("Start Trading\n")
      setText(pushbutton_trading,"Stop Trading")
    end if

    item_sell_name=getItem( List1, getIndex(List1) )
  item_buy_name=getItem( List2, getIndex(List2) )

  item_sell_cost=real(getText(textbox_amount1))
  item_buy_cost=real(getText(textbox_amount2))

  for i=1 to length(item_ids) do
    if equal(item_sell_name,item_ids[i][2])=1 then
      item_sell_id=item_ids[i][1]
      item_short_sell_name=item_ids[i][2]
    end if
    if equal(item_buy_name,item_ids[i][2])=1 then
      item_buy_id=item_ids[i][1]
      item_short_buy_name=item_ids[i][2]
    end if
  end for

  --owner_name=getText(textbox_owner_name)

  target_position[1]=real(getText(textbox_target_x))
  target_position[2]=real(getText(textbox_target_y))

  enable_move_to_target=isChecked(checkbox_move_to_target)
  enable_auto_login=isChecked(checkbox_auto_login)

  if isChecked(checkbox_message_mode)=1 then
    spam_message={"Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name,
    "Selling> "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name}

    --spam_message=lower({"S "&sprint(item_sell_cost)&" "&item_short_sell_name&" For "&sprint(item_buy_cost)&" "&item_short_buy_name,
   --"S> "&sprint(item_sell_cost)&" "&item_short_sell_name&" For "&sprint(item_buy_cost)&" "&item_short_buy_name})
  else
    spam_message={"Buying "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name,
    "Buying> "&sprint(item_buy_cost)&" "&item_buy_name&" For "&sprint(item_sell_cost)&" "&item_sell_name}
    --spam_message=lower({"B "&sprint(item_buy_cost)&" "&item_short_buy_name&" For "&sprint(item_sell_cost)&" "&item_short_sell_name,
   --"B> "&sprint(item_buy_cost)&" "&item_short_buy_name&" For "&sprint(item_sell_cost)&" "&item_short_sell_name})
  end if

  if isChecked(checkbox_can_tell_owner)=1 then
    playertext_packet_write("/tell "&owner_name&" Selling "&sprint(item_sell_cost)&" "&item_sell_name&" For "&sprint(item_buy_cost)&" "&item_buy_name)
  end if

  if isChecked(check_enable_custom_message)=1 and register1=1 and register2=1 then
  	spam_message=custom_message
  end if


end procedure
setHandler( pushbutton_trading, w32HClick, routine_id("pushbutton_trading_onClick"))
--------------------------------------------------------------------------------
procedure PushButton20_onClick (integer self, integer event, sequence params)--params is ()
  request_teleport=1
end procedure
setHandler( PushButton20, w32HClick, routine_id("PushButton20_onClick"))
--------------------------------------------------------------------------------
procedure PushButton21_onClick (integer self, integer event, sequence params)--params is ()
  integer fn
fn=open("config.txt","w")
puts(fn,getText(textbox_email)&"\n")
puts(fn,getText(textbox_password)&"\n")
puts(fn,getText(textbox_owner_name)&"\n")
puts(fn,sprint(getIndex(List1)) &"\n")
puts(fn,sprint(getIndex(List2)) &"\n")
puts(fn,getText(textbox_amount1)&"\n")
puts(fn,getText(textbox_amount2)&"\n")
puts(fn,getText(textbox_target_x)&"\n")
puts(fn,getText(textbox_target_y)&"\n")
puts(fn,sprint(isChecked(checkbox_move_to_target))&"\n")
puts(fn,sprint(isChecked(checkbox_auto_login))&"\n")
puts(fn,sprint(isChecked(checkbox_can_tell_owner))&"\n")
puts(fn,sprint(isChecked(checkbox_sound_tradedone))&"\n")
puts(fn,sprint(isChecked(checkbox_message_mode))&"\n")
puts(fn,sprint(getIndex(combox_serverlist)) &"\n")
puts(fn,sprint(isChecked(check_enable_custom_message))&"\n")
puts(fn,getText(textbox_chattime)&"\n")
puts(fn,sprint(isChecked(checkbox_showname))&"\n")
puts(fn,getText(textbox_rotmg_build_version)&"\n")
close(fn)


fn=open("custom message.txt","w")
for i=1 to length(custom_message) do
  	puts(fn,custom_message[i]&"\n")
end for
close(fn)

end procedure
setHandler( PushButton21, w32HClick, routine_id("PushButton21_onClick"))
--------------------------------------------------------------------------------
procedure PushButton33_onClick (integer self, integer event, sequence params)--params is ()
  setText(textbox_minimap_x,getText(textbox_target_x))
  setText(textbox_minimap_y,getText(textbox_target_y))
  openWindow(Window2,Modal)
end procedure
setHandler( PushButton33, w32HClick, routine_id("PushButton33_onClick"))
--------------------------------------------------------------------------------
procedure PushButton30_onClick (integer self, integer event, sequence params)--params is ()
  draw_my_items()
end procedure
setHandler( PushButton30, w32HClick, routine_id("PushButton30_onClick"))
--------------------------------------------------------------------------------
procedure PushButton79_onClick (integer self, integer event, sequence params)--params is ()
  if inv_select=1 then
    setCheck(checkbox_slot1,0)
    setCheck(checkbox_slot2,0)
    setCheck(checkbox_slot3,0)
    setCheck(checkbox_slot4,0)
    setCheck(checkbox_slot5,0)
    setCheck(checkbox_slot6,0)
    setCheck(checkbox_slot7,0)
    setCheck(checkbox_slot8,0)
  	inv_select=0

  elsif inv_select=0 then
    setCheck(checkbox_slot1,1)
    setCheck(checkbox_slot2,1)
    setCheck(checkbox_slot3,1)
    setCheck(checkbox_slot4,1)
    setCheck(checkbox_slot5,1)
    setCheck(checkbox_slot6,1)
    setCheck(checkbox_slot7,1)
    setCheck(checkbox_slot8,1)
  	inv_select=1
  end if

end procedure
setHandler( PushButton79, w32HClick, routine_id("PushButton79_onClick"))
--------------------------------------------------------------------------------
procedure PushButton83_onClick (integer self, integer event, sequence params)--params is ()
  if register1=1 and register2=1 then
    setTimer(Window1,1099,real(getText(textbox_chattime))*1000)
  else
    setText(textbox_chattime,sprint(45))
  end if
end procedure
setHandler( PushButton83, w32HClick, routine_id("PushButton83_onClick"))
--------------------------------------------------------------------------------

-- minimap_buffer,  -- copy to TheWindow
--                  0, 0,     -- put at {10,10} in TheWindow
--                  255, 255,    -- cause it to be this size
--                  minimap_bitmap,       -- copy from loaded bitmap
--                  90, 90,        -- upper left hand corner is {0,0}
--                  80, 70,     -- copy a 40x40 pixel portion
--                  SRCCOPY )   -- replace destination with image

function scale_mouse(integer startx, integer starty, integer width, integer height, integer mx, integer my  )
	atom scalex,scaley
	integer x,y
	scalex=width/minimap_width
	scaley=height/minimap_height
	
    x=(floor(mx*scalex)+startx)+1
    y=(floor(my*scaley)+starty)+1

    if x>startx+width then
      x=startx+width
    end if
    if y>startx+height then
      y=startx+height
    end if
	
    return {floor(x/2),floor(y/2)}
end function
--------------------------------------------------------------------------------
procedure Window2_onMouse (integer self, integer event, sequence params)--params is ( int event, int x, int y, int shift, int wheelmove )
sequence pos
  if params[1]=MouseMove then
    pos=scale_mouse(90,90,80,70,params[2],params[3])
  	setText(label_x,"x: "&sprint(pos[1]))
  	setText(label_y,"Y: "&sprint(pos[2]))
  elsif params[1]=LeftDown then
    pos=scale_mouse(90,90,80,70,params[2],params[3])
  	setText(textbox_minimap_x,sprint(pos[1]))
  	setText(textbox_minimap_y,sprint(pos[2]))
  end if
end procedure
setHandler( Window2, w32HMouse, routine_id("Window2_onMouse"))
--------------------------------------------------------------------------------
procedure Window2_onPaint (integer self, integer event, sequence params)--params is ( int x1, int y1, int x2, int y2 )
sequence pos
  pos={0,0}
  copyBlt( minimap_buffer,0,0,minimap_bitmap)

  stretchBlt( minimap_buffer,  -- copy to TheWindow
                  0, 0,     -- put at {10,10} in TheWindow
                  255, 255,    -- cause it to be this size
                  minimap_bitmap,       -- copy from loaded bitmap
                  90, 90,        -- upper left hand corner is {0,0}
                  80, 70,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
  --setPenColor( minimap_buffer, Green )
  --pos[1]=floor( real(getText(textbox_target_x))*(255/(90+80)) )
  --pos[2]=floor( real(getText(textbox_target_y))*(255/(90+70)) )

  --drawRectangle( minimap_buffer, w32True, pos[1], pos[2],pos[1]+4,pos[2]+4 )
  --setPixel(minimap_buffer,real(getText(textbox_target_x)),real(getText(textbox_target_y)),White)
  copyBlt( Window2, 0, 0, minimap_buffer )
end procedure
setHandler( Window2, w32HPaint, routine_id("Window2_onPaint"))
--------------------------------------------------------------------------------
procedure PushButton34_onClick (integer self, integer event, sequence params)--params is ()
  copyBlt( minimap_buffer,0,0,minimap_bitmap)
  stretchBlt( minimap_buffer,  -- copy to TheWindow
                  0, 0,     -- put at {10,10} in TheWindow
                  255, 255,    -- cause it to be this size
                  minimap_bitmap,       -- copy from loaded bitmap
                  90, 90,        -- upper left hand corner is {0,0}
                  80, 70,     -- copy a 40x40 pixel portion
                  SRCCOPY )   -- replace destination with image
  copyBlt( Window2, 0, 0, minimap_buffer )
end procedure
setHandler( PushButton34, w32HClick, routine_id("PushButton34_onClick"))
--------------------------------------------------------------------------------
procedure PushButton35_onClick (integer self, integer event, sequence params)--params is ()
  target_position[1]=real(getText(textbox_minimap_x))
  target_position[2]=real(getText(textbox_minimap_y))
  setText(textbox_target_x,getText(textbox_minimap_x))
  setText(textbox_target_y,getText(textbox_minimap_y))
  closeWindow(Window2)
end procedure
setHandler( PushButton35, w32HClick, routine_id("PushButton35_onClick"))
--------------------------------------------------------------------------------
procedure PushButton36_onClick (integer self, integer event, sequence params)--params is ()
  closeWindow(Window2)
end procedure
setHandler( PushButton36, w32HClick, routine_id("PushButton36_onClick"))
--------------------------------------------------------------------------------
procedure button_generate_onClick (integer self, integer event, sequence params)--params is ()
  sequence temp
  integer ret
  ret = message_box("Warning don't generate a new serial while waiting to for the serial key\nThe activation key will be invalid and no refund will be given\nDo you want to generate a new serial?","Warning",MB_YESNO)

  if ret=IDNO then
    returnValue(1)
    return
  end if

  ret = message_box("Warning don't generate a new serial while waiting to for serial\nThe activation key will be invalid and no refund will be given  \nDo you want to generate a new serial?","Warning Confirm",MB_YESNO)

  if ret=IDNO then
    returnValue(1)
    return
  end if

  temp=int_to_bytes(w32Func(xttime,{}))
  setText(textbox_serial,toBase64( serial_encrypt_client_xor(buildguid & temp & sprint(length(buildguid)+4))  ) )
  fn=open("reg.dat","w")
  puts(fn,getText(textbox_serial)&"\n")
  puts(fn,"serial key\n")
  close(fn)
end procedure
setHandler( button_generate, w32HClick, routine_id("button_generate_onClick"))
--------------------------------------------------------------------------------
procedure PushButton58_onClick (integer self, integer event, sequence params)--params is ()

sequence data,pid
atom ttime,ftime
integer len,fn

  data=serial_encrypt_server_xor(fromBase64(getText(textbox_serial_key)))

  if length(data)>2 then

  	len=real(data[(length(data)-1)..length(data)])

  	data=data[1..(length(data)-2)]
  	
  	if len=length(data) then

  	
  	if length(data)>4 then
  	  ttime=bytes_to_int(data[(length(data)-3)..length(data)])
  	  data=data[1..(length(data)-4)]
  	  ftime=bytes_to_int(data[(length(data)-3)..length(data)])
	  data=data[1..(length(data)-4)]
	  pid=data
	
	  if length(product_id)!=0 and equal(pid,product_id)=1 and ftime=reg_get_serial_timestamp() and ttime<=ftime+((60*60*24)*30) then
	    fn=open("reg.dat","w")
	    puts(fn,getText(textbox_serial)&"\n")
        puts(fn,getText(textbox_serial_key)&"\n")
        setEnable(button_generate,0)
	    setText(lable_message,"Botmaker, The only verified legitimate download mpgh.net. Registered remaining days: "&sprint( floor( (ttime-w32Func(xttime,{}))/((60*60)*24) ) ))
        close(fn)
        closeWindow(Window3)
	  end if

  	end if
  	
    end if
  	
  end if
end procedure
setHandler( PushButton58, w32HClick, routine_id("PushButton58_onClick"))
--------------------------------------------------------------------------------
procedure PushButton68_onClick (integer self, integer event, sequence params)--params is ()
sequence text,temp
integer pos
pos=1
  temp={}

  text=getText(textbox_custom_text)
  for i=1 to length(text) do
  	if text[i]=13 and text[i+1]=10 then
  	   temp=append(temp,text[pos..i-1])
       pos=i+2
  	end if
  end for
  if pos!=1 then

   --?text[length(text)-1]
   --?text[length(text)]
   if text[length(text)-1]=13 and text[length(text)] then
   else
      temp=append(temp,text[pos..length(text)])
   end if
   custom_message=temp
   --?length(custom_message)
  else
    --error
  end if
  --puts(1,)
  closeWindow(Window4)
end procedure
setHandler( PushButton68, w32HClick, routine_id("PushButton68_onClick"))


WinMain( Window1,Normal )
--this program has 3784 lines without including this line. If there is a discrepancy please send this file zipped to Judith.
